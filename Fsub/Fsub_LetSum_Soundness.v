(** Type-safety proofs for Fsub.

    Authors: Brian Aydemir and Arthur Chargu\'eraud, with help from
    Aaron Bohannon, Jeffrey Vaughan, and Dimitrios Vytiniotis.

    In parentheses are given the label of the corresponding lemma in
    the appendix (informal proofs) of the POPLmark Challenge.

    Table of contents:
      - #<a href="##subtyping">Properties of subtyping</a>#
      - #<a href="##typing">Properties of typing</a>#
      - #<a href="##preservation">Preservation</a>#
      - #<a href="##progress">Progress</a># *)

Require Export Fsub.Fsub_LetSum_Lemmas.
Require Import Coq.Program.Equality.


(* ********************************************************************** *)
(** * #<a name="subtyping"></a># Properties of subtyping *)

Lemma wf_cap_in : forall E (x : atom) (xs : atoms),
  x `in` xs ->
  wf_cap E (cset_set xs {}N) ->
  wf_cap E (cset_fvar x).
Proof with eauto.
  intros * xInxs wfCapE.
  constructor.
  intros.
  replace a with x in * by AtomSetDecide.fsetdec.
  inversion wfCapE...
Qed.

Lemma wf_cap_binds_sub_cap : forall E (x : atom) C,
  binds x (bind_sub_cap C) E ->
  wf_cap E (cset_fvar x).
Proof with eauto.
  intros * H.
  apply wf_cset_set.
  intros.
  left. eapply ex_intro.
  replace a with x in * by AtomSetDecide.fsetdec.
  apply H.
Qed.

Lemma wf_cap_binds_typ : forall E (x : atom) C Sh,
  binds x (bind_typ (pair Sh C)) E ->
  wf_cap E (cset_fvar x).
Proof with eauto.
  intros * H.
  apply wf_cset_set.
  intros.
  right. eapply ex_intro.
  replace a with x in * by AtomSetDecide.fsetdec.
  apply H.
Qed.


(* ********************************************************************** *)
(** ** Reflexivity (1) *)

Lemma sub_cap_reflexivity : forall E C,
  wf_env E ->
  wf_cap E C ->
  sub_cap E C C.
Proof with eauto.
  intros E C Ok Wf.
  induction Wf...
  * apply sub_cap_bound... intros a aIna...
Qed.

Lemma sub_shp_reflexivity: forall E Sh,
  wf_env E ->
  wf_shp E Sh ->
  sub_shp E Sh Sh
with sub_typ_reflexivity: forall E T,
  wf_env E ->
  wf_typ E T ->
  sub_typ E T T.
Proof with eauto.
  -----
  clear sub_shp_reflexivity.
  intros E Sh Ok Wf.
  induction Wf...
  * pick fresh X and apply sub_shp_arrow...
  * pick fresh X and apply sub_shp_sall...
  * pick fresh X and apply sub_shp_call...
    apply sub_cap_reflexivity...
  -----
  clear sub_typ_reflexivity.
  intros E T Ok Wf.
  induction Wf...
  apply sub_shp_reflexivity in H...
  apply sub_cap_reflexivity in H0...
Qed.


(* ********************************************************************** *)
(** ** Weakening (2) *)

Lemma sub_cap_weakening : forall E F G S T,
  sub_cap (G ++ E) S T ->
  wf_env (G ++ F ++ E) ->
  sub_cap (G ++ F ++ E) S T.
Proof with simpl_env; auto using wf_cap_weakening.
  intros E F G S T Sub Ok.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Sub; intros G OK EQ; subst...
  * apply sub_cap_cvar with (C:= C)...
  * apply sub_cap_var with (C:= C) (Sh:= Sh)...
  * apply sub_cap_bound... intros a aInxs.
    apply H3...
Qed.

Lemma sub_shp_weakening : forall E F G S T,
  sub_shp (G ++ E) S T ->
  wf_env (G ++ F ++ E) ->
  sub_shp (G ++ F ++ E) S T
with sub_typ_weakening: forall E F G S T,
  sub_typ (G ++ E) S T ->
  wf_env (G ++ F ++ E) ->
  sub_typ (G ++ F ++ E) S T.
Proof with simpl_env; auto using wf_cap_weakening; auto using wf_shp_weakening; auto using wf_typ_weakening.
  -----
  clear sub_shp_weakening.
  intros E F G S T Sub Ok.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Sub; intros G OK EQ; subst...
  * apply (sub_shp_trans_tvar U _ _ _).
    ** apply binds_app_iff in H.
       apply binds_app_iff. rewrite binds_app_iff.
       destruct H...
    ** apply (IHSub G)...
  * apply (sub_shp_arrow (union L (union (dom G) (union (dom F) (dom E)))) _ _ _ _ _)...
    intros X XnInL.
    remember (X ~ bind_typ T1 ++ G ++ E).
    apply union_rewrite in XnInL. inversion XnInL.
    apply (sub_typ_weakening _ _ (X ~ bind_typ T1 ++ G) (open_ct S2 (cset_fvar X)) (open_ct T2 (cset_fvar X)))...
  * apply (sub_shp_sall (union L (union (dom G) (union (dom F) (dom E)))) _ _ _ _ _)...
    intros X XnInL.
    apply (sub_typ_weakening _ _ (X ~ bind_sub_shp T1 ++ G) (open_st S2 X) (open_st T2 X))...
  * apply (sub_shp_call (union L (union (dom G) (union (dom F) (dom E)))) _ _ _ _ _)...
    apply sub_cap_weakening...
    intros X XnInL.
    apply (sub_typ_weakening _ _ (X ~ bind_sub_cap T1 ++ G) (open_ct S2 (cset_fvar X)) (open_ct T2 (cset_fvar X)))...
  -----
  clear sub_typ_weakening.
  intros E F G S T Sub Ok.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Sub; intros G OK EQ; subst...
  apply sub_typ_pair.
  apply sub_cap_weakening...
  apply sub_shp_weakening...
Qed.


(* ********************************************************************** *)
(** ** Narrowing and transitivity (3) *)

Definition transitivity_on_shp Q := forall E S T,
  sub_shp E S Q -> sub_shp E Q T -> sub_shp E S T.

Definition transitivity_on_cap Q := forall E S T,
  sub_cap E S Q -> sub_cap E Q T -> sub_cap E S T.

Definition transitivity_on_typ Q := forall E S T,
  sub_typ E S Q -> sub_typ E Q T -> sub_typ E S T.

(* Narrowing and transitivity on a shape *)

Lemma sub_cap_narrowing_shp_aux : forall Q F E Z P S T,
  transitivity_on_shp Q ->
  sub_cap (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp E P Q ->
  sub_cap (F ++ Z ~ bind_sub_shp P ++ E) S T.
Proof with simpl_env; eauto using wf_typ_narrowing_shp,
   wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap,
   wf_cap_narrowing_shp, wf_cap_in.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * apply sub_cap_cvar with (C:=C)...
    analyze_binds H...
  * apply sub_cap_var with (Sh:=Sh) (C:=C)...
    analyze_binds H...
  * apply sub_cap_bound...
    intros x xInxs. apply (H3 x xInxs F)...
Qed.

Lemma sub_shp_narrowing_shp_aux : forall Q F E Z P S T,
  transitivity_on_shp Q ->
  sub_shp (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp E P Q ->
  sub_shp (F ++ Z ~ bind_sub_shp P ++ E) S T
with sub_typ_narrowing_shp_aux : forall Q F E Z P S T,
  transitivity_on_shp Q ->
  sub_typ (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp E P Q ->
  sub_typ (F ++ Z ~ bind_sub_shp P ++ E) S T.
Proof with simpl_env; unshelve eauto using wf_typ_narrowing_shp, wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap;
  eauto.
  -----
  clear sub_shp_narrowing_shp_aux.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * apply sub_shp_top...
  * apply sub_shp_refl_tvar...
  * analyze_binds H.
    ** apply (sub_shp_trans_tvar U _ _ _)...
    ** inversion BindsTacVal.
       apply (sub_shp_trans_tvar P _ _ _)...
       rewrite H0 in IHSsubT.
       apply TransQ.
       *** rewrite <- app_assoc.
           rewrite <- (app_nil_1 _ ((F ++ Z ~ bind_sub_shp P) ++ E)).
           apply (sub_shp_weakening E (F ++ Z ~ bind_sub_shp P) empty)...
       *** apply (IHSsubT F)...
    ** apply (sub_shp_trans_tvar U _ _ _)...
  * apply (sub_shp_arrow L)...
    intros X XnInL.
    apply (sub_typ_narrowing_shp_aux Q (X ~ bind_typ T1 ++ F) E Z P _ _)...
  * apply (sub_shp_sall L)...
    intros X XnInL.
    apply (sub_typ_narrowing_shp_aux Q (X ~ bind_sub_shp T1 ++ F) E Z P _ _)...
  * apply (sub_shp_call L)...
    apply (sub_cap_narrowing_shp_aux Q F E Z P _ _)...
    intros X XnInL.
    apply (sub_typ_narrowing_shp_aux Q (X ~ bind_sub_cap T1 ++ F))...
-----
  clear sub_typ_narrowing_shp_aux.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  apply sub_typ_pair...
  apply (sub_cap_narrowing_shp_aux Q)...
Qed.


(* Narrowing and Transitivity on capture sets *)

Lemma sub_cap_narrowing_cap_aux : forall Q F E Z P S T,
  transitivity_on_cap Q ->
  sub_cap (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_cap (F ++ Z ~ bind_sub_cap P ++ E) S T.
Proof with simpl_env; unshelve eauto using wf_typ_narrowing_shp, wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap; eauto.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * apply sub_cap_universal...
  * apply sub_cap_in...
  * analyze_binds H...
    inversion BindsTacVal. subst...
    unfold transitivity_on_cap in TransQ...
    apply sub_cap_cvar with (C:=P)...
    apply TransQ...
    rewrite_env (empty ++ E) in PsubQ.
    eapply sub_cap_weakening in PsubQ.
    simpl_env in PsubQ.
    rewrite_env ((F ++ Z ~bind_sub_cap P) ++ E).
    apply PsubQ.
    simpl_env.
    unshelve epose proof (IHSsubT _ _)...
  * analyze_binds H...
  * apply sub_cap_bound...
    intros a aInxs. apply (H3 a aInxs)...
Qed.

Lemma sub_shp_narrowing_cap_aux : forall Q F E Z P S T,
  transitivity_on_cap Q ->
  sub_shp (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_shp (F ++ Z ~ bind_sub_cap P ++ E) S T
with sub_typ_narrowing_cap_aux : forall Q F E Z P S T,
  transitivity_on_cap Q ->
  sub_typ (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_typ (F ++ Z ~ bind_sub_cap P ++ E) S T.
Proof with simpl_env; unshelve eauto using wf_typ_narrowing_shp, wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap;
  eauto.
  -----
  clear sub_shp_narrowing_cap_aux.
  intros Q F E Z P S T transQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * apply sub_shp_top...
  * apply sub_shp_refl_tvar...
  * analyze_binds H...
    ** apply sub_shp_trans_tvar with (U:=U)...
    ** apply sub_shp_trans_tvar with (U:=U)...
  * apply sub_shp_arrow with (L:=L)...
    intros X XnInL.
    rewrite <- app_assoc.
    apply (sub_typ_narrowing_cap_aux Q (X ~ bind_typ T1 ++ F) E _ _ _ _)...
  * apply sub_shp_sall with (L:=L)...
    intros X XnInL.
    rewrite <- app_assoc.
    apply (sub_typ_narrowing_cap_aux Q (X ~ bind_sub_shp T1 ++ F) E _ _ _ _)...
  * apply sub_shp_call with (L:=L)...
    apply (sub_cap_narrowing_cap_aux Q F E _ _ _ _)...
    intros X XnInL.
    apply (sub_typ_narrowing_cap_aux Q (X ~ bind_sub_cap T1 ++ F) E _ _ _ _)...
  -----
  clear sub_typ_narrowing_cap_aux.
  intros Q F E Z P S T transQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  apply sub_typ_pair...
  apply sub_cap_narrowing_cap_aux with (Q:=Q)...
Qed.

(* #[export] Hint Resolve wf_cap_in: core. *)

Lemma sub_transitivity_cap : forall Q,
  transitivity_on_cap Q.
Proof with simpl_env; auto.
  unfold transitivity_on_cap.
  intros Q E S T SsubQ QsubT.
  assert (W : capture Q).
  apply sub_cap_regular in SsubQ. destruct SsubQ as [wfE [wfCs wfCQ]].
  apply (capture_from_wf_cap E)...
  generalize dependent T.
  generalize dependent S.
  generalize dependent E.
  remember Q as Q' in |- *.
  generalize dependent Q'.
  induction W;
    intros Q' EQ E S SsubQ;
    induction SsubQ; try discriminate; inversion EQ; subst;
    intros T' QsubT;
    inversion QsubT; subst;
    eauto 4 using sub_cap_universal;
    eauto 4 using sub_cap_cvar;
    eauto 4 using sub_cap_var; try solve [replace x with x0 in * by AtomSetDecide.fsetdec; eauto];
    try solve [apply sub_cap_universal; eauto; apply (wf_cap_in _ _ As); eauto]...
    * apply sub_cap_universal... apply wf_cap_binds_sub_cap with (C:=C)...
    * apply sub_cap_universal... apply wf_cap_binds_typ with (C:=C) (Sh:=Sh)...
    * apply sub_cap_bound...
      intros a aInxs.
      apply (H3 a aInxs)...
    * apply sub_cap_bound...
      intros a aInxs.
      apply (H3 a)...
    * apply sub_cap_bound...
      intros a aInxs.
      apply (H3 a)...
    * apply sub_cap_bound...
      intros a aInxs.
      apply (H3 a)...
Qed.

Lemma sub_cap_narrowing_cap : forall Q E F Z P S T,
  sub_cap E P Q ->
  sub_cap (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap (F ++ Z ~ bind_sub_cap P ++ E) S T.
Proof.
  intros.
  eapply sub_cap_narrowing_cap_aux; eauto.
  apply sub_transitivity_cap.
Qed.

Lemma sub_shp_narrowing_cap : forall Q E F Z P S T,
  sub_cap E P Q ->
  sub_shp (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_shp (F ++ Z ~ bind_sub_cap P ++ E) S T.
Proof.
  intros.
  eapply sub_shp_narrowing_cap_aux; eauto.
  apply sub_transitivity_cap.
Qed.

Lemma sub_typ_narrowing_cap : forall Q E F Z P S T,
  sub_cap E P Q ->
  sub_typ (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_typ (F ++ Z ~ bind_sub_cap P ++ E) S T.
Proof.
  intros.
  eapply sub_typ_narrowing_cap_aux; eauto.
  apply sub_transitivity_cap.
Qed.

(* Narrowing and Transitivity on typs *)

Lemma sub_cap_narrowing_typ_aux : forall Q F E Z P S T,
  transitivity_on_typ Q ->
  sub_cap (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_typ E P Q ->
  sub_cap (F ++ Z ~ bind_typ P ++ E) S T.
Proof with simpl_env; eauto using wf_typ_narrowing_shp, 
    wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap, wf_env_narrowing_typ,
    wf_cap_narrowing_typ.
  intros Q F E Z P S T transQ SsubT PsubQ.
  remember (F ++ Z ~ bind_typ Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * analyze_binds H...
  * analyze_binds H...
    - assert (wf_typ E P)...
      inversion H; subst...
      eapply sub_cap_var with (Sh := S) (C := C0)...
      inversion PsubQ; inversion BindsTacVal; subst...
      inversion H9; subst...
      eapply sub_transitivity_cap...
      rewrite_env (empty ++ (F ++ Z ~ bind_typ (pair S C0)) ++ E).
      eapply sub_cap_weakening...
  * apply sub_cap_bound... 
    intros a aInx. apply (H3 a)...
Qed.

Lemma sub_shp_narrowing_typ_aux : forall Q F E Z P S T,
  transitivity_on_typ Q ->
  sub_shp (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_typ E P Q ->
  sub_shp (F ++ Z ~ bind_typ P ++ E) S T
with sub_typ_narrowing_typ_aux : forall Q F E Z P S T,
  transitivity_on_typ Q ->
  sub_typ (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_typ E P Q ->
  sub_typ (F ++ Z ~ bind_typ P ++ E) S T.
Proof with simpl_env; eauto using wf_typ_narrowing_shp, wf_typ_narrowing_cap, wf_env_narrowing_shp, wf_env_narrowing_cap.
  -----
  clear sub_shp_narrowing_typ_aux.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_typ Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * apply sub_shp_top...
    ** apply wf_env_narrowing_typ with (V:=Q)...
    ** apply wf_shp_narrowing_typ with (V:=Q)...
  * apply sub_shp_refl_tvar...
    ** apply wf_env_narrowing_typ with (V:=Q)...
    ** apply wf_shp_narrowing_typ with (V:=Q)...
  * apply sub_shp_trans_tvar with (U:=U)...
    analyze_binds H...
  * apply sub_shp_arrow with (L:=L)...
    intros X XnInL...
    apply sub_typ_narrowing_typ_aux with (Q:=Q) (F:=(X ~ bind_typ T1 ++ F)) (E:=E)...
  * apply sub_shp_sall with (L:=L)...
    intros X XnInL...
    apply sub_typ_narrowing_typ_aux with (Q:=Q) (F:=(X ~ bind_sub_shp T1 ++ F)) (E:=E)...
  * apply sub_shp_call with (L:=L)...
    ** apply sub_cap_narrowing_typ_aux with (Q:=Q)...
    ** intros X XnInL...
       apply sub_typ_narrowing_typ_aux with (Q:=Q) (F:=(X ~ bind_sub_cap T1 ++ F)) (E:=E)...
-----
  clear sub_typ_narrowing_typ_aux.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_typ Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  apply sub_typ_pair...
  apply sub_cap_narrowing_typ_aux with (Q:=Q)...
Qed.

Lemma sub_transitivity_shp_shape : forall Q,
  shape Q -> transitivity_on_shp Q
with sub_transitivity_typ_type : forall Q,
  type Q -> transitivity_on_typ Q.
Proof with simpl_env; auto.
-----
  clear sub_transitivity_shp_shape.
  unfold transitivity_on_shp.
  intros Q W E S T SsubQ QsubT.
  generalize dependent T.
  generalize dependent S.
  generalize dependent E.
  remember Q as Q' in |- *.
  generalize dependent Q'.
  induction W;
    intros Q' EQ E Sh SsubQ;
    induction SsubQ; try discriminate; inversion EQ; subst;
    intros T' QsubT;
    inversion QsubT; subst; eauto using sub_shp_trans_tvar...
  * apply sub_shp_top...
    apply wf_shp_arrow with (L:=L0)...
    intros x xnInL.
    destruct (sub_typ_regular (x ~ bind_typ T1 ++ E) (open_ct S2 (cset_fvar x)) (open_ct T2 (cset_fvar x))) as [wfE [wfTS2 wfT1]]...
    apply (wf_typ_narrowing_typ T1 S1 (open_ct S2 (cset_fvar x)) E empty x)...
  * apply sub_shp_arrow with (L := L `union` L0 `union` L1)...
    apply sub_transitivity_typ_type with (Q:=T1)...
    intros X XnInL1...
    apply sub_transitivity_typ_type with (Q:=(open_ct T2 (cset_fvar X)))...
    rewrite_env (empty ++ X ~ bind_typ T0 ++ E).
    eapply sub_typ_narrowing_typ_aux with (Q := T1)...
  * apply sub_shp_top...
    apply wf_shp_sall with (L:=L0)...
    intros X XnInL.
    apply (wf_typ_narrowing_shp S _ (open_st S2 X) E empty X)...
    destruct (H0 X)...
  * unshelve epose proof (IHW S _)...
    apply sub_shp_sall with (L := L `union` L0 `union` L1)...
    intros X XnInL0L1.
    apply sub_transitivity_typ_type with (Q:=(open_st T X))...
    apply sub_typ_narrowing_shp_aux with (F:=empty) (Q:=S)...
    intros E' S' T'...
  * apply sub_shp_top...
    apply wf_shp_call with (L:=L0)...
    intros X XnInL0.
    apply (wf_typ_narrowing_cap C _ _ E empty X)...
    destruct (H2 X)...
  * apply sub_shp_call with (L := L `union` L0 `union` L1)...
    eapply sub_transitivity_cap with (Q := C)...
    intros X XnInL0L1...
    eapply sub_transitivity_typ_type...
    rewrite_env (empty ++ X ~ bind_sub_cap T1 ++ E).
    eapply sub_typ_narrowing_cap with (Q := C)...
-----
  clear sub_transitivity_typ_type.
  unfold transitivity_on_typ.
  intros Q W E S T SsubQ QsubT.
  generalize dependent T.
  generalize dependent S.
  generalize dependent E.
  remember Q as Q' in |- *.
  generalize dependent Q'.
  induction W;
    intros Q' EQ E Sh' SsubQ;
    induction SsubQ; try discriminate; inversion EQ; subst;
    intros T' QsubT;
    inversion QsubT; subst; eauto using sub_shp_trans_tvar...
  econstructor...
  eapply sub_transitivity_cap with (Q := C)...
  eapply sub_transitivity_shp_shape with (Q := Sh)...
Qed.


Lemma sub_transitivity_shp : forall Q,
  transitivity_on_shp Q
with sub_transitivity_typ : forall Q,
  transitivity_on_typ Q.
Proof with simpl_env; auto.
-----
  intros.
  unfold transitivity_on_shp; intros.
  eapply sub_transitivity_shp_shape with (Q := Q)...
-----
  intros.
  unfold transitivity_on_typ; intros.
  eapply sub_transitivity_typ_type with (Q := Q)...
Qed.

Lemma sub_shp_narrowing_typ : forall Q E F Z P S T,
  sub_typ E P Q ->
  sub_shp (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_shp (F ++ Z ~ bind_typ P ++ E) S T.
Proof.
  intros.
  eapply sub_shp_narrowing_typ_aux; eauto.
  apply sub_transitivity_typ.
Qed.

Lemma sub_typ_narrowing_typ : forall Q E F Z P S T,
  sub_typ E P Q ->
  sub_typ (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_typ (F ++ Z ~ bind_typ P ++ E) S T.
Proof.
  intros.
  eapply sub_typ_narrowing_typ_aux; eauto.
  apply sub_transitivity_typ.
Qed.

Lemma sub_cap_narrowing_typ : forall Q E F Z P S T,
  sub_typ E P Q ->
  sub_cap (F ++ Z ~ bind_typ Q ++ E) S T ->
  sub_cap (F ++ Z ~ bind_typ P ++ E) S T.
Proof.
  intros.
  eapply sub_cap_narrowing_typ_aux; eauto.
  apply sub_transitivity_typ.
Qed.



Lemma sub_cap_narrowing_shp : forall Q E F Z P S T,
  sub_shp E P Q ->
  sub_cap (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_cap (F ++ Z ~ bind_sub_shp P ++ E) S T.
Proof.
  intros.
  eapply sub_cap_narrowing_shp_aux; eauto.
  apply sub_transitivity_shp.
Qed.

Lemma sub_shp_narrowing_shp : forall Q E F Z P S T,
  sub_shp E P Q ->
  sub_shp (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp (F ++ Z ~ bind_sub_shp P ++ E) S T.
Proof.
  intros.
  eapply sub_shp_narrowing_shp_aux; eauto.
  apply sub_transitivity_shp.
Qed.

Lemma sub_typ_narrowing_shp : forall Q E F Z P S T,
  sub_shp E P Q ->
  sub_typ (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_typ (F ++ Z ~ bind_sub_shp P ++ E) S T.
Proof.
  intros.
  eapply sub_typ_narrowing_shp_aux; eauto.
  apply sub_transitivity_shp.
Qed.

Lemma wf_env_remove_head : forall F E,
  wf_env (F ++ E) ->
  wf_env E.
Proof with eauto.
  intros.
  dependent induction F; simpl_env in *...
  inversion H...
Qed.

Lemma wf_cap_strengthen : forall x b F E A,
  wf_cap (F ++ x ~ b ++ E) (cset_set A {}N) ->
  x `notin` A ->
  wf_cap (F ++ E) (cset_set A {}N).
Proof with eauto.
  intros.
  econstructor...
  intros a aIna...
  inversion H; subst...
  destruct (H3 a)...
  * destruct H1...
    analyze_binds H1...
  * destruct H1...
    analyze_binds H1...
Qed.

Lemma wf_cap_ignore_map : forall F E A Z P,
  wf_cap (F ++ E) (cset_set A {}N) ->
  wf_cap (map (subst_cb Z P) F ++ E) (cset_set A {}N).
Proof with eauto.
  intros.
  econstructor...
  intros a aIna...
  inversion H; subst...
  destruct (H2 a)...
  * destruct H0...
    analyze_binds H0...
    left... exists (subst_cc Z P x)...
  * destruct H0... 
    analyze_binds H0...
    right... exists (subst_ct Z P x)...
Qed.  

Lemma wf_cap_ignore_map_subst_sb : forall F E A Z P,
  wf_cap (F ++ E) (cset_set A {}N) ->
  wf_cap (map (subst_sb Z P) F ++ E) (cset_set A {}N).
Proof with eauto.
  intros.
  econstructor...
  intros a aIna...
  inversion H; subst...
  destruct (H2 a)...
  * destruct H0...
    analyze_binds H0...
    left... exists x.
    replace (bind_sub_cap x) with (subst_sb Z P (bind_sub_cap x))...
  * destruct H0... 
    analyze_binds H0...
    right... destruct x. exists (pair (subst_ss Z P s) c).
    replace (bind_typ (pair (subst_ss Z P s) c)) with (subst_sb Z P (bind_typ (pair s c)))...
Qed.  

Lemma sub_cap_strengthening_shp : forall X U E F S T,
  sub_cap (F ++ X ~ bind_sub_shp U ++ E) S T ->
  sub_cap (map (subst_sb X U) F ++ E) S T.
Proof with eauto using wf_env_subst_sbs.
  intros X U E F S T SsubT.
  assert (wf_shp E U) as WfShp. {
    eapply wf_shp_from_wf_env_sub_shp with (x := X)...
    eapply wf_env_remove_head...
  }
  remember (F ++ X ~ bind_sub_shp U ++ E) as E'.
  generalize dependent F.
  induction SsubT; intros F EQ; subst...
  * eapply sub_cap_universal...
    inversion H0; subst...
    eapply wf_cap_ignore_map_subst_sb...
    eapply wf_cap_strengthen...
    intro XinA. destruct (H1 X) as [[U' Binds]|[V' Binds]]...
    analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
    analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
  * eapply sub_cap_in...
    eapply wf_cap_ignore_map_subst_sb...
    eapply wf_cap_strengthen...
    inversion H0; subst...
    intro XinA. destruct (H4 X) as [[U' Binds]|[V' Binds]]...
    analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
    analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
  * eapply sub_cap_cvar...
    analyze_binds H...
    replace (bind_sub_cap C) with (subst_sb X U (bind_sub_cap C))...
  * analyze_binds H...
    eapply sub_cap_var with (Sh := subst_ss X U Sh)...
    replace (bind_typ (pair (subst_ss X U Sh) C)) 
      with (subst_sb X U (bind_typ (pair Sh C)))...
  * eapply sub_cap_bound...
    + inversion H0; subst...
      eapply wf_cap_ignore_map_subst_sb...
      eapply wf_cap_strengthen...
      intro XinA. destruct (H6 X) as [[U' Binds]|[V' Binds]]...
      analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
      analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
    + inversion H1; subst...
      eapply wf_cap_ignore_map_subst_sb...
      eapply wf_cap_strengthen...
      intro XinA. destruct (H6 X) as [[U' Binds]|[V' Binds]]...
      analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail...
      analyze_binds Binds. eapply fresh_mid_head... eapply fresh_mid_tail... 
    + intros x Xin.
      eapply H3...
Qed.

(* ********************************************************************** *)
(** ** Type substitution preserves subtyping (10) *)

Lemma nil_app : forall E F,
  empty = E ++ F ->
  E = empty /\ F = empty.
Proof with eauto.
  intros.  dependent induction F; simpl_env in *; eauto;
    dependent induction E; simpl_env in *...
  inversion H.
Qed.

(** Edward:: I think these discharge through analyze_binds *)
Lemma binds_var_sub_cap : forall A C G Q E,
  binds A (bind_sub_cap C) (G ++ A ~ bind_sub_cap Q ++ E) ->
  wf_env (G ++ A ~ bind_sub_cap Q ++ E) ->
  C = Q.
Proof with eauto.
  intros.
  analyze_binds H; subst...
  * exfalso. eapply fresh_mid_head...
  * inversion BindsTacVal...
  * exfalso. eapply fresh_mid_tail...
Qed.

Lemma binds_var_sub_shp : forall A C G Q E,
  binds A (bind_sub_shp C) (G ++ A ~ bind_sub_shp Q ++ E) ->
  wf_env (G ++ A ~ bind_sub_shp Q ++ E) ->
  C = Q.
Proof with eauto.
  intros.
  analyze_binds H; subst...
  * exfalso. eapply fresh_mid_head...
  * inversion BindsTacVal...
  * exfalso. eapply fresh_mid_tail...
Qed.

Lemma binds_var_typ : forall A C G Q E,
  binds A (bind_typ C) (G ++ A ~ bind_typ Q ++ E) ->
  wf_env (G ++ A ~ bind_typ Q ++ E) ->
  C = Q.
Proof with eauto.
  intros.
  analyze_binds H; subst...
  * exfalso. eapply fresh_mid_head...
  * inversion BindsTacVal...
  * exfalso. eapply fresh_mid_tail...
Qed.

Lemma uniq_from_wf_env: forall E,
  wf_env E -> uniq E.
Proof with eauto.
  intros E Hwf.
  destruct Hwf...
Qed.

Lemma binds_dom : forall T a (b : T) E,
  binds a b E ->
  a `in` (dom E).
Proof with eauto.
  intros T a b E H...
Qed.

Lemma binds_var_typ_cap_contra: forall A T G Q E,
  wf_env (G ++ A ~ bind_sub_cap Q ++ E) ->
  ~ (binds A (bind_typ T) (G ++ A ~ bind_sub_cap Q ++ E)).
Proof with eauto.
  intros.
  apply uniq_from_wf_env in H.
  intro B.
  analyze_binds B; subst...
  * apply uniq_app_3 in H.
    eapply (AtomSetImpl.empty_1 (H A _)).
    Unshelve.
    apply AtomSetFacts.inter_iff. split. 
    ** apply binds_dom in BindsTac...
    ** apply dom_app...
       apply AtomSetImpl.union_2.
       apply dom_cons...
  * rewrite <- app_assoc in H.
    apply uniq_app_3 in H.
    eapply (AtomSetImpl.empty_1 (H A _)).
    Unshelve.
    apply AtomSetFacts.inter_iff. split. 
    ** apply dom_app...
       apply AtomSetImpl.union_3.
       apply dom_cons...
    ** apply binds_dom in BindsTac0...
Qed.

Lemma sub_universal_cap : forall C E,
  sub_cap E cset_universal C ->
  C = cset_universal.
Proof with eauto.
  intros C E H...
  remember cset_universal.
  destruct H eqn:h; try discriminate.
  * symmetry. apply Heqc.
Qed.

Lemma sub_cap_through_subst_ce: forall Sh Q E F Z S T P,
  sub_cap (F ++ Z ~ bind_typ (pair Sh Q) ++ E) S T ->
  sub_cap E P Q ->
  sub_cap (map (subst_cb Z P) F ++ E) (subst_cc Z P S) (subst_cc Z P T).
Proof with
      simpl_env;
      try repeat rewrite <- AtomSetFacts.mem_iff in *; 
      try repeat rewrite <- AtomSetFacts.not_mem_iff in *; 
      try repeat rewrite <- union_empty_nats in *;
      try rewrite AtomSetEqual; try rewrite NatSetEqual;
      try AtomSetDecide.fsetdec; try fnsetdec;
      eauto 4 using 
        wf_typ_subst_cbc,
        wf_env_subst_cbc,
        wf_cap_subst_cbc,
        wf_env_subst_cbc,
        wf_env_subst_tb,
        wf_cap_subst_cbt,
        wf_typ_weaken_head,
        wf_cap_weaken_head,
        wf_cap_binds_sub_cap,
        wf_cap_from_binds_typ,
        wf_cap_from_binds_cap,
        sub_cap_reflexivity.
  intros Sh Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_typ (pair Sh Q) ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl subst_cc...
  * eapply sub_cap_universal...
  * (* sub_cap_in *)
    inversion H0...
    assert (wf_cap E P) as WfP... inversion WfP; subst...
    - destruct (x == Z) eqn:XZ; subst...
      + unfold subst_cc; simpl;
        destruct (AtomSetImpl.mem Z (singleton Z)) eqn:ZinZ;
        destruct (AtomSetImpl.mem Z ys) eqn:ZinY...
      + unfold subst_cc; simpl;
        destruct (AtomSetImpl.mem Z (singleton x)) eqn:ZinZ;
        destruct (AtomSetImpl.mem Z ys) eqn:ZinY...
        -- eapply sub_cap_universal...
           econstructor. intros. assert (a = x)...
           subst...
           unshelve epose proof (H4 x _) as BindsX...
           destruct BindsX as [[U Binds]|[V Binds]];
            analyze_binds Binds...
           ** left. exists (subst_cc Z cset_universal U)...
           ** right. exists (subst_ct Z cset_universal V)...
        -- eapply sub_cap_in...
           econstructor. intros. 
           unshelve epose proof (H4 a _) as BindsA...
           destruct BindsA as [[U Binds]|[V Binds]];
            analyze_binds Binds...
           ** left. exists (subst_cc Z cset_universal U)...
           ** right. exists (subst_ct Z cset_universal V)...
    - assert (wf_cap E (cset_set A0 {}N)) as WfA...
      assert (wf_cap (map (subst_cb Z (cset_set A0 {}N)) G ++ E)
        (cset_set (union (remove Z ys) A0) {}N)). {
        econstructor. intros a Ain...
        rewrite AtomSetFacts.union_iff in Ain; destruct Ain as [Ain|Ain]...
        - assert (a <> Z)...
          destruct (H4 a) as [[U Binds]|[V Binds]]...
          + analyze_binds Binds...
            left; exists (subst_cc Z (cset_set A0 {}N) U)...
          + analyze_binds Binds... 
            right; exists (subst_ct Z (cset_set A0 {}N) V)...
        - destruct (H5 a) as [[U Binds]|[V Binds]]...
      }
      destruct (x == Z) eqn:XZ; subst...
      + unfold subst_cc; simpl;
        destruct (AtomSetImpl.mem Z (singleton Z)) eqn:ZinZ;
        destruct (AtomSetImpl.mem Z ys) eqn:ZinY...
        replace (union (remove Z (singleton Z)) A0) with A0...
        eapply sub_cap_bound...
        intros a0 a0In...
      + unfold subst_cc; simpl;
        destruct (AtomSetImpl.mem Z (singleton x)) eqn:ZinZ;
        destruct (AtomSetImpl.mem Z ys) eqn:ZinY...
        -- eapply sub_cap_in...
        -- eapply sub_cap_in...
           econstructor. intros. 
           unshelve epose proof (H4 a _) as BindsA...
           destruct BindsA as [[U Binds]|[V Binds]];
             analyze_binds Binds...
           ** left. exists (subst_cc Z  (cset_set A0 {}N) U)...
           ** right. exists (subst_ct Z  (cset_set A0 {}N) V)...
  * (* sub_cap_var *)
    assert (wf_cap E P) as WfP...
    unshelve epose proof (IHSsubT _ _) as SubCapSubst...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_set ys {}N)))
      as WfYSubst...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_fvar x)))
      as WfXSubst. {
      eapply wf_cap_subst_cbt with (Q := (pair Sh Q))...
    }
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P C))
      as WfCSubst...
    repeat (unfold subst_cc in *; simpl in *);
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:ZinZ;
      destruct (AtomSetImpl.mem Z ys) eqn:ZinY;
      inversion WfP; subst;  repeat (unfold subst_cc in *; simpl in *);
      fold subst_cc in *; simpl_env in *...
    - assert (Z = x); subst...
      replace (union (remove x (singleton x)) A) with A...
      eapply sub_cap_bound...
      intros a aInA.
      eapply sub_cap_in...
    - assert (Z = x); subst... 
      inversion PsubQ; subst...
      analyze_binds H; [exfalso; eapply fresh_mid_head; eauto|exfalso; eapply fresh_mid_tail; eauto].
    - assert (Z = x); subst...
      analyze_binds H; [exfalso; eapply fresh_mid_head; eauto|exfalso; eapply fresh_mid_tail; eauto].
    - assert (Z <> x)...
      eapply sub_transitivity_cap with (Q := (subst_cc Z (cset_set A {}N) C))...
      inversion WfCSubst; subst...
      analyze_binds H...
      + eapply sub_cap_cvar with (C := (subst_cc Z (cset_set A {}N) C))...
        rewrite H2...
      + eapply sub_cap_cvar with (C := cset_set A0 {}N)...
        assert (wf_cap E (cset_fvar x)) as WfX...
        assert (wf_cap E C) as WfC... 
        apply binds_app_3...
        rewrite <- subst_cc_fresh with (Z := Z) in H2; subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
    - assert (Z <> x)...
      eapply sub_transitivity_cap with (Q := (subst_cc Z cset_universal C))...
      analyze_binds H...
      + inversion WfCSubst...
        eapply sub_cap_cvar...
        rewrite H...
      + inversion WfCSubst...
        assert (wf_cap E (cset_fvar x)) as WfX...
        assert (wf_cap E C) as WfC... 
        eapply sub_cap_cvar...
        rewrite H...
        apply binds_app_3...
        rewrite <- subst_cc_fresh; subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
    - eapply sub_cap_bound...
      intros x' x'Inx...
      assert (x' = x); subst...
      eapply sub_transitivity_cap with (Q := (subst_cc Z (cset_set A {}N) C))...
      analyze_binds H...
      + inversion WfCSubst...
        eapply sub_cap_cvar with (C := (subst_cc Z (cset_set A {}N) C))...
        rewrite H...
      + inversion WfCSubst...
        eapply sub_cap_cvar with (C := (subst_cc Z(cset_set A {}N) C))...
        rewrite H...
        assert (wf_cap E (cset_fvar x)) as WfX...
        assert (wf_cap E C) as WfC... 
        apply binds_app_3...
        rewrite <- subst_cc_fresh with (Z := Z); subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
  * (* sub_cap_cvar *)
    assert (wf_cap E P) as WfP...
    assert (wf_cap (G ++ Z ~ bind_typ (pair Sh Q) ++ E) (cset_fvar x)) as WfX... {
      econstructor; intros...
      assert (a = x); subst...
    }
    unshelve epose proof (IHSsubT _ _) as SubCapSubst...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_set ys {}N)))
      as WfYSubst...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_fvar x)))
      as WfXSubst. {
      eapply wf_cap_subst_cbt with (Q := (pair Sh Q))...
    }
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P C))
      as WfCSubst...
    assert (wf_cap E Q) as WfQ...
    repeat (unfold subst_cc in *; simpl in *);
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:ZinZ;
      destruct (AtomSetImpl.mem Z ys) eqn:ZinY;
      inversion WfP; subst;  repeat (unfold subst_cc in *; simpl in *);
      fold subst_cc in *; simpl_env in *...
    - assert (Z = x); subst...
      replace (union (remove x (singleton x)) A) with A...
      eapply sub_cap_bound...
      intros a aInA.
      eapply sub_cap_in...
    - assert (Z = x); subst... 
      inversion PsubQ; subst...
      analyze_binds H; [exfalso; eapply fresh_mid_head; eauto| | exfalso; eapply fresh_mid_tail; eauto].
      inversion BindsTacVal; subst...
    - assert (Z = x); subst...
      analyze_binds H; [exfalso; eapply fresh_mid_head; eauto| | exfalso; eapply fresh_mid_tail; eauto].
      inversion BindsTacVal; subst...
      replace (union (remove x (singleton x)) A) with A...
      eapply sub_transitivity_cap with (Q := Q)...
      + rewrite_env (empty ++ map (subst_cb x (cset_set A {}N)) G ++ E).
        eapply sub_cap_weakening...
      + erewrite subst_cc_fresh with (T := Q) (Z := x)...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
    - assert (Z <> x)...
      eapply sub_transitivity_cap with (Q := (subst_cc Z (cset_set A {}N) C))...
      inversion WfCSubst; subst...
      analyze_binds H...
      + eapply sub_cap_var with (C := (subst_cc Z (cset_set A {}N) C)) 
          (Sh := (subst_cs Z (cset_set A {}N) Sh0))...
        rewrite H2...
        replace (bind_typ (pair (subst_cs Z (cset_set A {}N) Sh0) (subst_cc Z (cset_set A {}N) C)))
          with (subst_cb Z (cset_set A{}N) (bind_typ (pair Sh0 C)))...
      + eapply sub_cap_var with (C := cset_set A0 {}N)...
        apply binds_app_3...
        rewrite <- subst_cc_fresh with (Z := Z) in H2; subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
    - assert (Z <> x)...
      eapply sub_transitivity_cap with (Q := (subst_cc Z cset_universal C))...
      analyze_binds H...
      + inversion WfCSubst; subst...
        eapply sub_cap_var with (C := cset_set A {}N) 
          (Sh := (subst_cs Z cset_universal Sh0))...
        rewrite H...
        replace (bind_typ (pair (subst_cs Z cset_universal Sh0) (subst_cc Z cset_universal C)))
        with (subst_cb Z cset_universal (bind_typ (pair Sh0 C)))...
      + inversion WfCSubst; subst...
        eapply sub_cap_var with (C := cset_set A {}N) (Sh := Sh0)...
        apply binds_app_3...
        rewrite H...
        rewrite <- subst_cc_fresh with (Z := Z) ; subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
    - eapply sub_cap_bound...
      intros x' x'Inx...
      assert (x' = x); subst...
      eapply sub_transitivity_cap with (Q := (subst_cc Z (cset_set A {}N) C))...
      analyze_binds H...
      + inversion WfCSubst...
        eapply sub_cap_var with (C := (subst_cc Z (cset_set A {}N) C))
          (Sh := (subst_cs Z (cset_set A {}N) Sh0))...
        rewrite H...
        replace (bind_typ (pair (subst_cs Z (cset_set A {}N) Sh0) (subst_cc Z (cset_set A {}N) C)))
          with (subst_cb Z (cset_set A{}N) (bind_typ (pair Sh0 C)))...
      + inversion WfCSubst...
        eapply sub_cap_var with (C := C) (Sh := Sh0)...
        rewrite H.
        rewrite <- subst_cc_fresh with (Z := Z) ; subst...
        eapply notin_fv_wf_cap with (E := E)...
        eapply fresh_mid_tail...
  * (* sub_cap_bound *)
    assert (wf_cap E P) as WfP...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_set ys {}N)))
      as WfYSubst...
    assert (wf_cap (map (subst_cb Z P) G ++ E) (subst_cc Z P (cset_set xs {}N)))
      as WfXSubst...
    repeat (unfold subst_cc in *; simpl in *);
      destruct (AtomSetImpl.mem Z xs) eqn:ZinX;
      destruct (AtomSetImpl.mem Z ys) eqn:ZinY;
      inversion WfP; subst;
      repeat (unfold subst_cc in *; simpl in *);
      fold subst_cc in *; simpl_env in *...
    - eapply sub_cap_bound...
      intros x xInxsA...
      rewrite AtomSetFacts.union_iff in *; destruct xInxsA...
      unshelve epose proof (H3 x _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:HZinX...
    - inversion PsubQ; subst...
      unshelve epose proof (H3 Z _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton Z)) eqn:HZinZ...
    - unshelve epose proof (H3 Z _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton Z)) eqn:HZinZ...
      replace (union (remove Z (singleton Z)) A) with A in *...
      eapply sub_cap_bound...
      intros x xInXsorA.
      rewrite AtomSetFacts.union_iff in *.
      destruct xInXsorA as [xInX | xInA]...
      + unshelve epose proof (H3 x _ _ _)...
        destruct (AtomSetImpl.mem Z (singleton x)) eqn:HZinX...
      + eapply sub_transitivity_cap with (Q := cset_set A {}N)...
    - eapply sub_cap_bound...
      intros x xInX.
      unshelve epose proof (H3 x _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:HZinX...
    - inversion PsubQ; subst...
      eapply sub_cap_bound...
      intros x XinX.
      unshelve epose proof (H3 x _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:HZinX...
    - eapply sub_cap_bound...
      intros x XinX.
      unshelve epose proof (H3 x _ _ _)...
      destruct (AtomSetImpl.mem Z (singleton x)) eqn:HZinX...
Qed.


Lemma sub_cap_through_subst_cc : forall Q E F Z S T P,
  sub_cap (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_cap (map (subst_cb Z P) F ++ E) (subst_cc Z P S) (subst_cc Z P T).
Proof with
      simpl_env;
      eauto 4 using 
        wf_typ_subst_cbc,
        wf_env_subst_cbc,
        wf_typ_weaken_head,
        wf_cap_binds_sub_cap,
        wf_cap_from_binds_cap,
        wf_cap_from_binds_typ.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl subst_cc...
  * replace (subst_cc Z P cset_universal) with cset_universal by auto.
    apply sub_cap_universal...
    apply wf_cap_subst_cbc with (Q:=Q)...
  * destruct (x == Z); destruct (AtomSetImpl.mem Z ys) eqn:Zinys...
    ** destruct P...
       *** replace (subst_cc Z cset_universal (cset_fvar x)) with cset_universal...
           replace (subst_cc Z cset_universal (cset_set ys {}N)) with cset_universal...
           unfold subst_cc... rewrite Zinys...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with true...
           symmetry. apply AtomSetFacts.mem_iff...
       *** replace t0 with {}N in *.
           unfold subst_cc... simpl... rewrite Zinys...
           replace (AtomSetImpl.mem Z (singleton x)) with true.
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           apply sub_cap_bound...
           replace (cset_set (union (remove Z (singleton x)) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_fvar x)).
           apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
           apply wf_cap_narrowing_cap with (V:=Q)...
           apply wf_cap_in with (xs:=ys)...
           unfold subst_cc... simpl... replace (AtomSetImpl.mem Z (singleton x)) with true.
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           symmetry. apply AtomSetFacts.mem_iff...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           intros x0 x0Inunion.
           apply sub_cap_in...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           AtomSetDecide.fsetdec.
           symmetry. apply AtomSetFacts.mem_iff...
           apply sub_cap_regular in PsubQ.
           destruct PsubQ as [_ [wfC _]].
           apply capture_from_wf_cap in wfC.
           remember (cset_set t t0).
           destruct wfC.
           inversion Heqc...
           discriminate Heqc.
    ** apply AtomSetFacts.not_mem_iff in Zinys.
       AtomSetDecide.fsetdec.
    ** destruct P...
       *** replace (subst_cc Z cset_universal (cset_set ys {}N)) with cset_universal.
           apply sub_cap_universal.
           apply wf_env_subst_cbc with (Q:=cset_universal).
           apply wf_env_narrowing_cap with (V:=Q)...
           auto.
           apply wf_cap_subst_cbc with (Q:=(cset_universal))...
           apply wf_cap_in with (xs:=ys)...
           apply wf_cap_narrowing_cap with (V:=Q)...
           unfold subst_cc... rewrite Zinys...
       *** replace t0 with {}N in *.
           replace (subst_cc Z (cset_set t {}N) (cset_fvar x)) with (cset_fvar x).
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           apply sub_cap_in...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N))...
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with false...
           symmetry. apply AtomSetFacts.not_mem_iff...
           apply sub_cap_regular in PsubQ.
           destruct PsubQ as [_ [wfC _]].
           apply capture_from_wf_cap in wfC.
           remember (cset_set t t0).
           destruct wfC...
           inversion Heqc...
           discriminate Heqc.
    ** replace (subst_cc Z P (cset_fvar x)) with (cset_fvar x).
       replace (subst_cc Z P (cset_set ys {}N)) with (cset_set ys {}N).
       apply sub_cap_in...
       replace (cset_set ys {}N) with (subst_cc Z P (cset_set ys {}N)).
       apply wf_cap_subst_cbc with (Q:=Q)...
       unfold subst_cc... rewrite Zinys...
       unfold subst_cc... rewrite Zinys...
       unfold subst_cc... simpl...
       replace (AtomSetImpl.mem Z (singleton x)) with false...
       symmetry.
       apply AtomSetFacts.not_mem_iff...
  * destruct (x == Z); destruct (AtomSetImpl.mem Z ys) eqn:Zinys...
    ** destruct P...
       *** replace (subst_cc Z cset_universal (cset_fvar x)) with cset_universal...
           replace (subst_cc Z cset_universal (cset_set ys {}N)) with cset_universal...
           unfold subst_cc... rewrite Zinys...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with true...
           symmetry. apply AtomSetFacts.mem_iff...
       *** replace t0 with {}N in *.
           unfold subst_cc... rewrite Zinys...
           simpl... replace (AtomSetImpl.mem Z (singleton x)) with true.
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           apply sub_cap_bound...
           replace (cset_set (union (remove Z (singleton x)) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_fvar x)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with true.
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           symmetry. apply AtomSetFacts.mem_iff...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N))...
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           intros a aInunion.
           apply sub_cap_in...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           AtomSetDecide.fsetdec.
           symmetry. apply AtomSetFacts.mem_iff...
           apply sub_cap_regular in PsubQ.
           destruct PsubQ as [_ [wfC _]].
           apply capture_from_wf_cap in wfC.
           remember (cset_set t t0).
           destruct wfC...
           inversion Heqc...
           discriminate Heqc.
    ** destruct P; destruct C...
       *** replace (subst_cc Z cset_universal (cset_fvar x)) with (subst_cc Z cset_universal cset_universal).
           apply (IHSsubT G)...
           unfold subst_cc. simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with true...
           symmetry. apply AtomSetFacts.mem_iff...
       *** apply sub_universal_cap in PsubQ.
           rewrite e in *.
           apply binds_var_sub_cap in H. rewrite PsubQ in H.
           discriminate H.
           apply sub_cap_regular in SsubT.
           destruct SsubT...
       *** apply sub_universal_cap in SsubT.
           discriminate SsubT.
       *** replace t0 with {}N in *. replace t2 with {}N in *.
           unfold subst_cc... simpl... rewrite Zinys...
           replace (AtomSetImpl.mem Z (singleton x)) with true.
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           replace (union (remove Z (singleton x)) t) with t.
           unfold subst_cc in IHSsubT... rewrite Zinys in IHSsubT...
           destruct (AtomSetImpl.mem Z t1) eqn:Zint1...
           **** replace (NatSetImpl.union {}N {}N) with {}N in IHSsubT by apply union_empty_nats...
                apply (sub_transitivity_cap (cset_set (union (remove Z t1) t) {}N)).
                apply sub_cap_bound...
                apply (wf_cap_weakening _ E (map (subst_cb Z (cset_set t {}N)) G) empty)...
                replace (cset_set (union (remove Z t1) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set t1 {}N))...
                apply wf_cap_subst_cbc with (Q:=Q)...
                unfold subst_cc... rewrite Zint1...
                replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
                intros x0 x0Int...
                apply sub_cap_in...
                replace (cset_set (union (remove Z t1) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set t1 {}N))...
                apply wf_cap_subst_cbc with (Q:=Q)...
                unfold subst_cc... rewrite Zint1...
                replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
                apply (IHSsubT G)...
           **** rewrite e in H.
                apply binds_var_sub_cap in H.
                rewrite <- H in *.
                apply (sub_transitivity_cap (cset_set t1 {}N))...
                apply (sub_cap_weakening E (map (subst_cb Z (cset_set t {}N)) G) empty)...
                apply sub_cap_regular in SsubT.
                destruct SsubT...
           **** apply AtomSetEqual...
                AtomSetDecide.fsetdec.
           **** symmetry. apply AtomSetFacts.mem_iff...
           **** apply sub_cap_regular in SsubT...
                destruct SsubT as [_ [wfC _]].
                apply capture_from_wf_cap in wfC.
                remember (cset_set t1 t2).
                destruct wfC...
                inversion Heqc...
                discriminate Heqc.
           **** apply sub_cap_regular in PsubQ...
                destruct PsubQ as [_ [wfC _]].
                apply capture_from_wf_cap in wfC.
                remember (cset_set t t0).
                destruct wfC...
                inversion Heqc...
                discriminate Heqc.
    ** destruct P...
       *** replace (subst_cc Z cset_universal (cset_set ys {}N)) with cset_universal...
           apply sub_cap_universal...
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinys...
       *** replace t0 with {}N in *.
           replace (subst_cc Z (cset_set t {}N) (cset_fvar x)) with (cset_fvar x).
           unfold subst_cc...
           rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           analyze_binds H...
           apply sub_cap_cvar with (C:=(subst_cc Z (cset_set t {}N) C))...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply (IHSsubT G)...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           apply sub_cap_cvar with (C:=C)...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           replace C with (subst_cc Z (cset_set t {}N) C).
           apply (IHSsubT G)...
           rewrite <- subst_cc_fresh with (Z:=Z) (U:=(cset_set t {}N))... subst...
           eapply notin_fv_wf_cap with (E:=E)...
           eapply fresh_mid_tail...
           unfold subst_cc... rewrite Zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with false...
           symmetry. apply AtomSetFacts.not_mem_iff...
           apply sub_cap_regular in PsubQ...
           destruct PsubQ as [_ [wfC _]].
           apply capture_from_wf_cap in wfC.
           remember (cset_set t t0).
           destruct wfC...
           inversion Heqc...
           discriminate Heqc...
    ** replace (subst_cc Z P (cset_fvar x)) with (cset_fvar x).
       replace (subst_cc Z P (cset_set ys {}N)) with (cset_set ys {}N).
       analyze_binds H...
       apply sub_cap_cvar with (C:=(subst_cc Z P C))...
       replace (cset_set ys {}N) with (subst_cc Z P (cset_set ys {}N)).
       apply (IHSsubT G)...
       unfold subst_cc... rewrite Zinys...
       apply sub_cap_cvar with (C:=C)...
       replace (cset_set ys {}N) with (subst_cc Z P (cset_set ys {}N))...
       replace C with (subst_cc Z P C)...
       rewrite <- subst_cc_fresh with (Z:=Z) (U:=P)...
       eapply notin_fv_wf_cap with (E:=E)...
       eapply fresh_mid_tail...
       unfold subst_cc...
       rewrite Zinys...
       unfold subst_cc...
       rewrite Zinys...
       unfold subst_cc...
       simpl...
       replace (AtomSetImpl.mem Z (singleton x)) with false...
       symmetry. apply AtomSetFacts.not_mem_iff...
  * destruct (x == Z)...
    ** rewrite e in *.
       apply binds_var_typ_cap_contra in H...
       destruct H.
    ** destruct P; destruct (AtomSetImpl.mem Z ys) eqn:zinys...
       *** replace (subst_cc Z cset_universal (cset_fvar x)) with (cset_fvar x).
           unfold subst_cc... rewrite zinys.
           apply sub_cap_universal...
           apply wf_cset_set...
           intros a aInx. replace a with x in * by AtomSetDecide.fsetdec.
           right.
           analyze_binds H...
           eapply ex_intro.
           apply binds_app_iff. left.
           Unshelve. 3 : {
             apply (subst_ct Z cset_universal (pair Sh C)).
           }
           replace (bind_typ (subst_ct Z cset_universal (pair Sh C))) with
             (subst_cb Z cset_universal (bind_typ (pair Sh C)))...
             unfold subst_cc... simpl... replace (AtomSetImpl.mem Z (singleton x)) with false.
             auto.
             symmetry. apply AtomSetFacts.not_mem_iff.
             AtomSetDecide.fsetdec.
       *** replace (subst_cc Z cset_universal (cset_set ys {}N)) with (cset_set ys {}N) in *.
           replace (subst_cc Z cset_universal (cset_fvar x)) with (cset_fvar x).
           apply sub_cap_var with (C:=(subst_cc Z cset_universal C)) (Sh:=(subst_cs Z cset_universal Sh)).
           apply (IHSsubT G)...
           replace (bind_typ (pair (subst_cs Z cset_universal Sh) (subst_cc Z cset_universal C))) with (subst_cb Z cset_universal (bind_typ (pair Sh C))).
           analyze_binds H.
           apply binds_app_iff... right.
           replace (subst_cb Z cset_universal (bind_typ (pair Sh C))) with (bind_typ (pair Sh C)).
           apply BindsTac0...
           simpl...
           f_equal... f_equal...
           rewrite <- subst_cs_fresh with (Z:=Z) (U:=cset_universal)...
           eapply notin_fv_wf_shp with (E:=E)...
           apply wf_shp_from_wf_typ with (C:=C)...
           apply wf_typ_from_binds_typ with (x:=x)...
           eapply fresh_mid_tail...
           rewrite <- subst_cc_fresh with (Z:=Z) (U:=cset_universal)...
           eapply notin_fv_wf_cap with (E:=E)...
           eapply fresh_mid_tail...
           unfold subst_cb...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with false.
           auto.
           symmetry. apply AtomSetFacts.not_mem_iff. AtomSetDecide.fsetdec.
           unfold subst_cc...
           rewrite zinys...
       *** replace (subst_cc Z (cset_set t t0) (cset_fvar x)) with (cset_fvar x).
           unfold subst_cc... rewrite zinys.
           replace (NatSetImpl.union {}N t0) with t0.
           replace t0 with {}N in *.
           apply sub_cap_var with (C:=(subst_cc Z (cset_set t {}N) C)) (Sh:=(subst_cs Z (cset_set t {}N) Sh))...
           replace (subst_cc Z (cset_set t {}N) (cset_set ys {}N)) with (cset_set (union (remove Z ys) t) {}N) in IHSsubT...
           unfold subst_cc... rewrite zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           replace (bind_typ (pair (subst_cs Z (cset_set t {}N) Sh) (subst_cc Z (cset_set t {}N) C))) with (subst_cb Z (cset_set t {}N) (bind_typ (pair Sh C))).
           analyze_binds H...
           apply binds_app_iff... right.
           replace (subst_cb Z (cset_set t {}N) (bind_typ (pair Sh C))) with (bind_typ (pair Sh C))...
           simpl...
           f_equal... f_equal...
           rewrite <- subst_cs_fresh with (Z:=Z) (U:=(cset_set t {}N))...
           eapply notin_fv_wf_shp with (E:=E)...
           apply wf_shp_from_wf_typ with (C:=C)...
           apply wf_typ_from_binds_typ with (x:=x)...
           eapply fresh_mid_tail...
           rewrite <- subst_cc_fresh with (Z:=Z) (U:=(cset_set t {}N))...
           eapply notin_fv_wf_cap with (E:=E)...
           eapply fresh_mid_tail...
           unfold subst_cb...
           apply sub_cap_regular in PsubQ.
           destruct PsubQ as [wfE [wfCcset wfCQ]].
           remember (cset_set t t0).
           destruct wfCcset...
           discriminate Heqc.
           inversion Heqc...
           apply NatSetEqual...
           NatSetDecide.fsetdec.
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with false...
           symmetry. apply AtomSetFacts.not_mem_iff.
           AtomSetDecide.fsetdec.
       *** replace (subst_cc Z (cset_set t t0) (cset_fvar x)) with (cset_fvar x).
           replace (subst_cc Z (cset_set t t0) (cset_set ys {}N)) with (cset_set ys {}N) in *.
           apply sub_cap_var with (C:=(subst_cc Z (cset_set t t0) C)) (Sh:=(subst_cs Z (cset_set t t0) Sh))...
           replace (bind_typ (pair (subst_cs Z (cset_set t t0) Sh) (subst_cc Z (cset_set t t0) C))) with (subst_cb Z (cset_set t t0) (bind_typ (pair Sh C)))...
           analyze_binds H...
           apply binds_app_iff. right.
           replace (subst_cb Z (cset_set t t0) (bind_typ (pair Sh C))) with (bind_typ (pair Sh C))...
           simpl...
           f_equal... f_equal...
           rewrite <- subst_cs_fresh with (Z:=Z) (U:=(cset_set t t0))...
           eapply notin_fv_wf_shp with (E:=E)...
           apply wf_shp_from_wf_typ with (C:=C)...
           apply wf_typ_from_binds_typ with (x:=x)...
           eapply fresh_mid_tail...
           rewrite <- subst_cc_fresh with (Z:=Z) (U:=(cset_set t t0))...
           eapply notin_fv_wf_cap with (E:=E)...
           eapply fresh_mid_tail...
           unfold subst_cc... rewrite zinys...
           unfold subst_cc... simpl...
           replace (AtomSetImpl.mem Z (singleton x)) with false...
           symmetry. apply AtomSetFacts.not_mem_iff...
  * destruct (AtomSetImpl.mem Z xs) eqn:Zinxs; destruct (AtomSetImpl.mem Z ys) eqn:zinys...
    ** unfold subst_cc... rewrite Zinxs... rewrite zinys...
       destruct P eqn:p...
       replace t0 with {}N in *.
       replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N)...
       apply sub_cap_bound...
       replace (cset_set (union (remove Z xs) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set xs {}N))...
       apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
       apply wf_cap_narrowing_cap with (V:=Q)...
       unfold subst_cc. rewrite Zinxs... replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N)...
       replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N))...
       apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
       apply wf_cap_narrowing_cap with (V:=Q)...
       unfold subst_cc. rewrite zinys... replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N)...
       intros a aInUnion.
       apply AtomSetImpl.union_1 in aInUnion.
       destruct aInUnion...
       *** replace (cset_fvar a) with (subst_cc Z (cset_set t {}N) (cset_fvar a)).
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply (H3 a)...
           AtomSetDecide.fsetdec.
           unfold subst_cc... rewrite zinys... replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N)...
           unfold subst_cc... simpl... replace (AtomSetImpl.mem Z (singleton a)) with false...
           symmetry.
           apply AtomSetFacts.not_mem_iff.
           AtomSetDecide.fsetdec.
       *** apply sub_cap_in...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
           apply wf_cap_narrowing_cap with (V:=Q)...
           unfold subst_cc... rewrite zinys... replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N)...
       *** apply sub_cap_regular in PsubQ. destruct PsubQ as [_ [wfcapset _]].
           apply capture_from_wf_cap in wfcapset.
           remember (cset_set t t0).
           destruct wfcapset.
           inversion Heqc...
           discriminate Heqc.
    ** unfold subst_cc... rewrite Zinxs... rewrite zinys...
       destruct P eqn:p...
       *** apply AtomSetFacts.mem_iff in Zinxs.
           replace (sub_cap (map (subst_cb Z cset_universal) G ++ E) cset_universal
  (cset_set ys {}N)) with (sub_cap (map (subst_cb Z cset_universal) G ++ E)
    (subst_cc Z cset_universal (cset_fvar Z))
    (subst_cc Z cset_universal (cset_set ys {}N))).
           apply (H3 Z Zinxs G (eq_refl (G ++ Z ~ bind_sub_cap Q ++ E)))...
           unfold subst_cc... simpl... rewrite zinys...
           replace (AtomSetImpl.mem Z (singleton Z)) with true...
           symmetry. apply AtomSetFacts.mem_iff. AtomSetDecide.fsetdec.
       *** replace t0 with {}N in *.
           replace (NatSetImpl.union {}N {}N) with {}N by apply (union_empty_nats {}N).
           apply sub_cap_bound...
           replace (cset_set (union (remove Z xs) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set xs {}N)).
           apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
           apply wf_cap_narrowing_cap with (V:=Q)...
           unfold subst_cc... rewrite Zinxs...
           f_equal...
           symmetry. apply union_empty_nats...
           replace (cset_set ys {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=(cset_set t {}N))...
           apply wf_cap_narrowing_cap with (V:=Q)...
           unfold subst_cc... rewrite zinys...
           intros a aInunion.
           apply AtomSetImpl.union_1 in aInunion.
           destruct aInunion...
           **** replace (cset_fvar a) with (subst_cc Z (cset_set t {}N) (cset_fvar a)).
                replace (cset_set ys {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
                eapply (H3 a _ G _)...
                Unshelve.
                unfold subst_cc... rewrite zinys...
                unfold subst_cc... simpl... 
                replace (AtomSetImpl.mem Z (singleton a)) with false...
                symmetry. apply AtomSetFacts.not_mem_iff...
                AtomSetDecide.fsetdec.
                AtomSetDecide.fsetdec.
                auto.
           **** unshelve epose proof (H3 Z _ _ _)...
                apply AtomSetFacts.mem_iff...
                replace (subst_cc Z (cset_set t {}N) (cset_fvar Z)) with (cset_set t {}N) in H5.
                replace (subst_cc Z (cset_set t {}N) (cset_set ys {}N)) with (cset_set ys {}N) in H5.
                apply sub_transitivity_cap with (Q:=(cset_set t {}N))...
                unfold subst_cc... rewrite zinys...
                unfold subst_cc... simpl... replace (AtomSetImpl.mem Z (singleton Z)) with true...
                replace (union (remove Z (singleton Z)) t) with t...
                replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
                apply AtomSetEqual... AtomSetDecide.fsetdec.
                symmetry. apply AtomSetFacts.mem_iff...
           **** apply sub_cap_regular in PsubQ.
                destruct PsubQ as [_ [wfset _]].
                apply capture_from_wf_cap in wfset.
                remember (cset_set t t0).
                destruct wfset.
                inversion Heqc...
                discriminate Heqc.
    ** unfold subst_cc... rewrite Zinxs... rewrite zinys...
       destruct P eqn:p...
       *** apply sub_cap_universal...
           replace (cset_set xs {}N) with (subst_cc Z cset_universal (cset_set xs {}N)).
           apply wf_cap_subst_cbc with (Q:=cset_universal)...
           apply wf_cap_narrowing_cap with (V:=Q)...
           unfold subst_cc... rewrite Zinxs...
       *** replace t0 with {}N in *...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           apply sub_cap_bound...
           replace (cset_set xs {}N) with (subst_cc Z (cset_set t {}N) (cset_set xs {}N)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite Zinxs...
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N)).
           apply wf_cap_subst_cbc with (Q:=Q)...
           unfold subst_cc... rewrite zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           intros a aInxs...
           replace (cset_fvar a) with (subst_cc Z (cset_set t {}N) (cset_fvar a)).
           replace (cset_set (union (remove Z ys) t) {}N) with (subst_cc Z (cset_set t {}N) (cset_set ys {}N))...
           unfold subst_cc... rewrite zinys...
           replace (NatSetImpl.union {}N {}N) with {}N by apply union_empty_nats...
           unfold subst_cc... simpl... replace (AtomSetImpl.mem Z (singleton a)) with false...
           symmetry. apply AtomSetFacts.not_mem_iff...
           apply AtomSetFacts.not_mem_iff in Zinxs...
           AtomSetDecide.fsetdec.
           apply sub_cap_regular in PsubQ.
           destruct PsubQ as [_ [wfset _]].
           apply capture_from_wf_cap in wfset.
           remember (cset_set t t0).
           destruct wfset.
           inversion Heqc...
           discriminate Heqc.
    ** unfold subst_cc... rewrite Zinxs... rewrite zinys...
       apply sub_cap_bound...
       replace (cset_set xs {}N) with (subst_cc Z P (cset_set xs {}N))...
       apply wf_cap_subst_cbc with (Q:=Q)...
       unfold subst_cc... rewrite Zinxs...
       replace (cset_set ys {}N) with (subst_cc Z P (cset_set ys {}N))...
       apply wf_cap_subst_cbc with (Q:=Q)...
       unfold subst_cc... rewrite zinys...
       intros a ainXs.
       replace (cset_set ys {}N) with (subst_cc Z P (cset_set ys {}N))...
       replace (cset_fvar a) with (subst_cc Z P (cset_fvar a)).
       apply (H3 a ainXs G)...
       unfold subst_cc... simpl...
       replace (AtomSetImpl.mem Z (singleton a)) with false...
       symmetry.
       apply AtomSetFacts.not_mem_iff. apply AtomSetFacts.not_mem_iff in Zinxs.
       AtomSetDecide.fsetdec.
       unfold subst_cc... rewrite zinys...
Qed.

Lemma sub_shp_through_subst_ss : forall Q E F Z S T P,
  sub_shp (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp E P Q ->
  sub_shp (map (subst_sb Z P) F ++ E) (subst_ss Z P S) (subst_ss Z P T)
with sub_typ_through_subst_ss : forall Q E F Z S T P,
  sub_typ (F ++ Z ~ bind_sub_shp Q ++ E) S T ->
  sub_shp E P Q ->
  sub_typ (map (subst_sb Z P) F ++ E) (subst_st Z P S) (subst_st Z P T).
Proof with
      simpl_env;
      eauto 4 using 
      sub_shp_reflexivity, 
      wf_shp_subst_sbs, 
      wf_typ_subst_sbs, 
      wf_env_subst_sbs, 
      wf_typ_weaken_head,
      wf_shp_weaken_head.
-----
  clear sub_shp_through_subst_ss.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  * eapply sub_shp_top...
  * destruct (X == Z); subst; eapply sub_shp_reflexivity...
    inversion H0; subst...
    analyze_binds H3...
    eapply wf_shp_fvar with (U := subst_ss Z P U)...
  * destruct (X == Z); subst...
    SCase "X = Z".
      apply (sub_transitivity_shp Q).
      SSCase "left branch".
        rewrite_env (empty ++ map (subst_sb Z P) G ++ E).
        apply sub_shp_weakening...
      SSCase "right branch".
        rewrite (subst_ss_fresh Z P Q).
          analyze_binds_uniq H.
            inversion BindsTacVal; subst...
          eapply notin_fv_wf_shp with (E := E); eauto using fresh_mid_tail.
    SCase "X <> Z".
      apply (sub_shp_trans_tvar (subst_ss Z P U))...
        rewrite (map_subst_sb_id E Z P);
          [ | auto | eapply fresh_mid_tail; eauto ].
        analyze_binds H...
  * pick fresh x and apply sub_shp_arrow...
    unfold open_ct. 
    rewrite <- subst_st_open_ct_rec...
    rewrite <- subst_st_open_ct_rec...
    rewrite_env (map (subst_sb Z P) (x ~ bind_typ T1 ++ G) ++ E).
    eapply sub_typ_through_subst_ss...
  * pick fresh X and apply sub_shp_sall...
    rewrite subst_st_open_st_var...
    rewrite subst_st_open_st_var...
    rewrite_env (map (subst_sb Z P) (X ~ bind_sub_shp T1 ++ G) ++ E).
    eapply sub_typ_through_subst_ss...
  * pick fresh X and apply sub_shp_call...
    eapply sub_cap_strengthening_shp.
    eapply sub_cap_narrowing_shp...
    unfold open_ct.
    rewrite <- subst_st_open_ct_rec...
    rewrite <- subst_st_open_ct_rec...
    rewrite_env (map (subst_sb Z P) (X ~ bind_sub_cap T1 ++ G) ++ E).
    eapply sub_typ_through_subst_ss...
-----
  clear sub_typ_through_subst_ss.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  eapply sub_typ_pair...
  eapply sub_cap_strengthening_shp.
  eapply sub_cap_narrowing_shp...
Qed. 

Lemma sub_shp_through_subst_sc : forall Q E F Z S T P,
  sub_shp (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_shp (map (subst_cb Z P) F ++ E) (subst_cs Z P S) (subst_cs Z P T)
with sub_typ_through_subst_sc : forall Q E F Z S T P,
  sub_typ (F ++ Z ~ bind_sub_cap Q ++ E) S T ->
  sub_cap E P Q ->
  sub_typ (map (subst_cb Z P) F ++ E) (subst_ct Z P S) (subst_ct Z P T).
Proof with
      simpl_env;
      eauto 4 using wf_typ_subst_sbs, wf_env_subst_sbs, wf_typ_weaken_head,
        sub_shp_reflexivity, 
        wf_shp_subst_sbs, 
        wf_typ_subst_sbs, 
        wf_env_subst_cbc, 
        wf_shp_subst_cbc, 
        wf_typ_subst_cbc, 
        wf_env_subst_sbs, 
        wf_typ_weaken_head,
        wf_shp_weaken_head.
-----
  clear sub_shp_through_subst_sc.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  * eapply sub_shp_top...
  * eapply sub_shp_reflexivity...
    inversion H0; subst...
    analyze_binds H3...
    eapply wf_shp_fvar with (U := subst_cs Z P U)...
  * analyze_binds H...
    apply (sub_shp_trans_tvar (subst_cs Z P U))...
    apply (sub_shp_trans_tvar U)...
    erewrite subst_cs_fresh with (T := U). apply IHSsubT...
    eapply notin_fv_wf_shp with (E := E)...
    eapply wf_shp_from_binds_shp...
    eapply fresh_mid_tail...
  * pick fresh x and apply sub_shp_arrow...
    unfold open_ct.
    erewrite subst_cc_fresh with (T := cset_fvar x)... 
    rewrite <- subst_ct_open_ct_rec...
    rewrite <- subst_ct_open_ct_rec...
    rewrite_env (map (subst_cb Z P) (x ~ bind_typ T1 ++ G) ++ E).
    eapply sub_typ_through_subst_sc...
  * pick fresh X and apply sub_shp_sall...
    rewrite <- subst_ct_open_st_var...
    rewrite <- subst_ct_open_st_var...
    rewrite_env (map (subst_cb Z P) (X ~ bind_sub_shp T1 ++ G) ++ E).
    eapply sub_typ_through_subst_sc...
  * pick fresh X and apply sub_shp_call...
    eapply sub_cap_through_subst_cc...
    unfold open_ct.
    erewrite subst_cc_fresh with (T := cset_fvar X)... 
    rewrite <- subst_ct_open_ct_rec...
    rewrite <- subst_ct_open_ct_rec...
    rewrite_env (map (subst_cb Z P) (X ~ bind_sub_cap T1 ++ G) ++ E).
    eapply sub_typ_through_subst_sc...
-----
  clear sub_typ_through_subst_sc.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  eapply sub_typ_pair...
  eapply sub_cap_through_subst_cc...
Qed.

Lemma sub_shp_through_subst_se : forall Sh CQ E F Z S T CP,
  sub_shp (F ++ Z ~ bind_typ (pair Sh CQ) ++ E) S T ->
  sub_cap E CP CQ ->
  sub_shp (map (subst_cb Z CP) F ++ E) (subst_cs Z CP S) (subst_cs Z CP T)
with sub_typ_through_subst_se : forall Sh CQ E F Z S T CP,
  sub_typ (F ++ Z ~ bind_typ (pair Sh CQ) ++ E) S T ->
  sub_cap E CP CQ ->
  sub_typ (map (subst_cb Z CP) F ++ E) (subst_ct Z CP S) (subst_ct Z CP T).
Proof with
  simpl_env;
  eauto 4 using wf_typ_subst_sbs, wf_env_subst_tb, wf_typ_weaken_head,
    sub_shp_reflexivity, 
    wf_shp_subst_sbs, 
    wf_typ_subst_sbs, 
    wf_env_subst_cbc, 
    wf_shp_subst_cbc, 
    wf_typ_subst_cbc, 
    wf_env_subst_sbs, 
    wf_env_subst_tb, 
    wf_shp_subst_cbt, 
    wf_typ_subst_cbt, 
    wf_typ_weaken_head,
    wf_shp_weaken_head.
-----
  clear sub_shp_through_subst_se.
  intros Sh CQ E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_typ (pair Sh CQ) ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  * eapply sub_shp_top...
  * eapply sub_shp_reflexivity...
    inversion H0; subst...
    analyze_binds H3...
    eapply wf_shp_fvar with (U := subst_cs Z P U)...
  * analyze_binds H...
    apply (sub_shp_trans_tvar (subst_cs Z P U))...
    apply (sub_shp_trans_tvar U)...
    erewrite subst_cs_fresh with (T := U). apply IHSsubT...
    eapply notin_fv_wf_shp with (E := E)...
    eapply wf_shp_from_binds_shp...
    eapply fresh_mid_tail...
  * pick fresh x and apply sub_shp_arrow...
    unfold open_ct.
    erewrite subst_cc_fresh with (T := cset_fvar x)... 
    rewrite <- subst_ct_open_ct_rec...
    rewrite <- subst_ct_open_ct_rec...
    rewrite_env (map (subst_cb Z P) (x ~ bind_typ T1 ++ G) ++ E).
    eapply sub_typ_through_subst_se...
  * pick fresh X and apply sub_shp_sall...
    rewrite <- subst_ct_open_st_var...
    rewrite <- subst_ct_open_st_var...
    rewrite_env (map (subst_cb Z P) (X ~ bind_sub_shp T1 ++ G) ++ E).
    eapply sub_typ_through_subst_se...
  * pick fresh X and apply sub_shp_call...
    eapply sub_cap_through_subst_ce...
    unfold open_ct.
    erewrite subst_cc_fresh with (T := cset_fvar X)... 
    rewrite <- subst_ct_open_ct_rec...
    rewrite <- subst_ct_open_ct_rec...
    rewrite_env (map (subst_cb Z P) (X ~ bind_sub_cap T1 ++ G) ++ E).
    eapply sub_typ_through_subst_se...
-----
  clear sub_typ_through_subst_se.
  intros Sh Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_typ (pair Sh Q) ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl...
  eapply sub_typ_pair...
  eapply sub_cap_through_subst_ce...
Qed.

(*
Lemma sub_through_subst_tt : forall Q E F Z S T P,
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (map (subst_tb Z P) F ++ E) (subst_tt Z P S) (subst_tt Z P T).
Proof with
      simpl_env;
      eauto 4 using wf_typ_subst_tb, wf_env_subst_tb, wf_typ_weaken_head.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl subst_tt...
  Case "sub_top".
    apply sub_top...
  Case "sub_refl_tvar".
    destruct (X == Z); subst.
    SCase "X = Z".
      apply sub_reflexivity...
    SCase "X <> Z".
      apply sub_reflexivity...
      inversion H0; subst.
      analyze_binds H3...
      apply (wf_typ_var (subst_tt Z P U))...
  Case "sub_trans_tvar".
    destruct (X == Z); subst.
    SCase "X = Z".
      apply (sub_transitivity Q).
      SSCase "left branch".
        rewrite_env (empty ++ map (subst_tb Z P) G ++ E).
        apply sub_weakening...
      SSCase "right branch".
        rewrite (subst_tt_fresh Z P Q).
          analyze_binds_uniq H.
            inversion BindsTacVal; subst...
          apply (notin_fv_wf E); eauto using fresh_mid_tail.
    SCase "X <> Z".
      apply (sub_trans_tvar (subst_tt Z P U))...
      rewrite (map_subst_tb_id E Z P);
        [ | auto | eapply fresh_mid_tail; eauto ].
      analyze_binds H...
  Case "sub_all".
    pick fresh X and apply sub_all...
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env (map (subst_tb Z P) (X ~ bind_sub T1 ++ G) ++ E).
    apply H0...
Qed.
 *)


(* ********************************************************************** *)
(** * #<a name="typing"></a># Properties of typing *)


(* ********************************************************************** *)
(** ** Weakening (5) *)

Lemma typing_weakening : forall E F G e T,
  typing (G ++ E) e T ->
  wf_env (G ++ F ++ E) ->
  typing (G ++ F ++ E) e T.
Proof with simpl_env;
           eauto using wf_typ_weakening,
                       wf_shp_weakening,
                       wf_cap_weakening,
                       wf_typ_from_wf_env_typ,
                       wf_shp_from_wf_env_sub_shp,
                       wf_cap_from_wf_env_sub_cap,
                       sub_shp_weakening,
                       sub_typ_weakening,
                       sub_cap_weakening.
  intros E F G e T Typ.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Typ; intros G EQ Ok; subst...
  Case "typing_abs".
    pick fresh x and apply typing_abs.
    lapply (H x); [intros K | auto].
    rewrite <- app_assoc.
    apply (H0 x)...
  Case "typing_sabs".
    pick fresh X and apply typing_sabs.
    lapply (H X); [intros K | auto].
    rewrite <- app_assoc.
    apply (H0 X)...
  Case "typing_cabs".
    pick fresh X and apply typing_cabs.
    lapply (H X); [intros K | auto].
    rewrite <- app_assoc.
    apply (H0 X)...
Qed.


(************************************************************************ *)
(** ** Narrowing for typing (7) *)

Lemma typing_narrowing_shp : forall Q E F X P e T,
  sub_shp E P Q ->
  typing (F ++ X ~ bind_sub_shp Q ++ E) e T ->
  typing (F ++ X ~ bind_sub_shp P ++ E) e T.
Proof with eauto 6 using wf_env_narrowing_cap, 
                          wf_env_narrowing_shp,
                          wf_typ_narrowing_cap, 
                          wf_typ_narrowing_shp,
                          wf_typ_narrowing_typ,
                          wf_shp_narrowing_cap,
                          wf_shp_narrowing_typ,
                          wf_shp_narrowing_typ,
                          wf_cap_narrowing_cap,
                          wf_cap_narrowing_shp,
                          wf_cap_narrowing_typ,
                          wf_cap_narrowing_shp,
                          sub_shp_narrowing_cap,
                          sub_shp_narrowing_typ,
                          sub_shp_narrowing_shp,
                          sub_cap_narrowing_cap,
                          sub_cap_narrowing_shp,
                          sub_cap_narrowing_typ,
                          sub_typ_narrowing_cap,
                          sub_typ_narrowing_shp,
                          sub_typ_narrowing_typ.
  intros Q E F X P e T PsubQ Typ.
  remember (F ++ X ~ bind_sub_shp Q ++ E) as E'.
  generalize dependent F.
  induction Typ; intros F EQ; subst...
  Case "typing_var".
    analyze_binds H0...
  Case "typing_abs".
    pick fresh y and apply typing_abs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_sabs".
    pick fresh Y and apply typing_sabs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_cabs".
    pick fresh Y and apply typing_cabs...
    rewrite <- app_assoc.
    apply H0...
Qed.

Lemma typing_narrowing_cap : forall Q E F X P e T,
  sub_cap E P Q ->
  typing (F ++ X ~ bind_sub_cap Q ++ E) e T ->
  typing (F ++ X ~ bind_sub_cap P ++ E) e T.
Proof with eauto 6 using wf_env_narrowing_cap, 
                          wf_env_narrowing_shp,
                          wf_typ_narrowing_cap, 
                          wf_typ_narrowing_shp,
                          wf_typ_narrowing_typ,
                          wf_shp_narrowing_cap,
                          wf_shp_narrowing_typ,
                          wf_shp_narrowing_typ,
                          wf_cap_narrowing_cap,
                          wf_cap_narrowing_shp,
                          wf_cap_narrowing_typ,
                          wf_cap_narrowing_shp,
                          sub_shp_narrowing_cap,
                          sub_shp_narrowing_typ,
                          sub_shp_narrowing_shp,
                          sub_cap_narrowing_cap,
                          sub_cap_narrowing_shp,
                          sub_cap_narrowing_typ,
                          sub_typ_narrowing_cap,
                          sub_typ_narrowing_shp,
                          sub_typ_narrowing_typ.
  intros Q E F X P e T PsubQ Typ.
  remember (F ++ X ~ bind_sub_cap Q ++ E) as E'.
  generalize dependent F.
  induction Typ; intros F EQ; subst...
  Case "typing_var".
    analyze_binds H0...
  Case "typing_abs".
    pick fresh y and apply typing_abs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_sabs".
    pick fresh Y and apply typing_sabs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_cabs".
    pick fresh Y and apply typing_cabs...
    rewrite <- app_assoc.
    apply H0...
Qed.


Lemma typing_narrowing_typ : forall Q E F X P e T,
  sub_typ E P Q ->
  typing (F ++ X ~ bind_typ Q ++ E) e T ->
  typing (F ++ X ~ bind_typ P ++ E) e T.
Proof with eauto 6 using wf_env_narrowing_cap, 
                          wf_env_narrowing_shp,
                          wf_typ_narrowing_cap, 
                          wf_typ_narrowing_shp,
                          wf_typ_narrowing_typ,
                          wf_shp_narrowing_cap,
                          wf_shp_narrowing_typ,
                          wf_shp_narrowing_typ,
                          wf_cap_narrowing_cap,
                          wf_cap_narrowing_shp,
                          wf_cap_narrowing_typ,
                          wf_cap_narrowing_shp,
                          sub_shp_narrowing_cap,
                          sub_shp_narrowing_typ,
                          sub_shp_narrowing_shp,
                          sub_cap_narrowing_cap,
                          sub_cap_narrowing_shp,
                          sub_cap_narrowing_typ,
                          sub_typ_narrowing_cap,
                          sub_typ_narrowing_shp,
                          sub_typ_narrowing_typ,
                          sub_typ_reflexivity,
                          wf_env_narrowing_typ.
  intros Q E F X P e T PsubQ Typ.
  remember (F ++ X ~ bind_typ Q ++ E) as E'.
  generalize dependent F.
  induction Typ; intros F EQ; subst...
  Case "typing_var".
    analyze_binds H0...
    inversion BindsTacVal; subst...
    assert (wf_typ E P) as WfP... inversion WfP; subst...
    eapply typing_sub with (S := (pair S0 (cset_fvar X)))...
    econstructor... eapply sub_cap_reflexivity...
    eapply wf_cap_binds_typ...
    inversion PsubQ; subst.
    rewrite_env (empty ++ (F ++ X ~ bind_typ (pair S0 C0)) ++ E).
    eapply sub_shp_weakening...
    simpl_env...
  Case "typing_abs".
    pick fresh y and apply typing_abs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_sabs".
    pick fresh Y and apply typing_sabs.
    rewrite <- app_assoc.
    apply H0...
  Case "typing_cabs".
    pick fresh Y and apply typing_cabs...
    rewrite <- app_assoc.
    apply H0...
Qed.


(************************************************************************ *)
(** ** Substitution preserves typing (8) *)

Lemma evaluate_subst_cc : forall x C,
  subst_cc x C (cset_fvar x) = C.
Proof with eauto.
  intros.
  unfold subst_cc; simpl.
  destruct (AtomSetImpl.mem x (singleton x)) eqn:HX;
    try rewrite AtomSetFacts.not_mem_iff in *;
    try AtomSetDecide.fsetdec.
  destruct C; f_equal; 
    try rewrite AtomSetEqual;
    try rewrite NatSetEqual; try AtomSetDecide.fsetdec;
    try NatSetDecide.fsetdec.
  
  rewrite <- AtomSetFacts.not_mem_iff in *.
  AtomSetDecide.fsetdec.
Qed.

Lemma capture_prediction : forall E u U C,
  value u ->
  typing E u (pair U C) ->
  sub_cap E (cset_set (fv_exp_for_cap u) {}N) C.
Proof with eauto using sub_cap_reflexivity; try discriminate.
  intros * Val Typ.
  assert (wf_cap E C) as WfCap...
  assert (wf_env E) as WfEnv...
  dependent induction Typ; try inversion Val; subst; simpl...
  * dependent induction H; subst... unshelve epose proof (IHTyp Sh1 C1 _ _ _ _)...
    eapply sub_transitivity_cap. eassumption. eauto.
  * dependent induction H; subst... unshelve epose proof (IHTyp Sh1 C1 _ _ _ _)...
    eapply sub_transitivity_cap. eassumption. eauto.
  * dependent induction H; subst... unshelve epose proof (IHTyp Sh1 C1 _ _ _ _)...
    eapply sub_transitivity_cap. eassumption. eauto.
Qed.

Lemma fv_exp_for_cap_through_subst_ee : forall x C u e,
  (cset_set (fv_exp_for_cap (subst_ee x C u e)) {}N) = 
    (subst_cc x (cset_set (fv_exp_for_cap u) {}N) (cset_set (fv_exp_for_cap e) {}N)).
Proof with eauto; 
  try repeat rewrite <- AtomSetFacts.mem_iff in *; 
  try repeat rewrite <- AtomSetFacts.not_mem_iff in *; 
  try rewrite AtomSetEqual; try rewrite NatSetEqual;
  try AtomSetDecide.fsetdec; try fnsetdec.
  intros.
  (*** this proof is cursed ****)
  induction e; simpl; unfold subst_cc in *; simpl in *...
  * destruct (AtomSetImpl.mem x _) eqn:XinE...
  * destruct (a == x); subst...
    + destruct (AtomSetImpl.mem x _) eqn:XinX; f_equal...
    + destruct (AtomSetImpl.mem x _) eqn:AinX; f_equal...
  * destruct (AtomSetImpl.mem x (fv_exp_for_cap e1)) eqn:XinE1;
    destruct (AtomSetImpl.mem x (fv_exp_for_cap e2)) eqn:XinE2;
    destruct (AtomSetImpl.mem x (union (fv_exp_for_cap e1) (fv_exp_for_cap e2)))
      eqn:XinE1E2;
      inversion IHe1; inversion IHe2; subst; f_equal;
      try rewrite H0; try rewrite H1; try rewrite H2...
Qed.


Lemma sub_cap_through_subst_ct_covariant : forall Q E F Z S P T,
  wf_env (F ++ Z ~ bind_typ T ++ E) ->
  wf_cap (F ++ Z ~ bind_typ T ++ E) S ->
  sub_cap E P Q ->
  sub_cap (map (subst_cb Z Q) F ++ E) (subst_cc Z P S) (subst_cc Z Q S).
Proof with
      repeat (simpl_env;
      try repeat rewrite <- AtomSetFacts.mem_iff in *; 
      try repeat rewrite <- AtomSetFacts.not_mem_iff in *; 
      try repeat rewrite AtomSetFacts.union_iff in *; 

      try repeat rewrite <- union_empty_nats in *;
      try rewrite AtomSetEqual; try rewrite NatSetEqual;
      try AtomSetDecide.fsetdec; try fnsetdec;
      eauto 4 using 
        wf_typ_subst_cbc,
        wf_env_subst_cbc,
        wf_env_subst_tb,
        wf_typ_weaken_head,
        sub_cap_reflexivity,
        wf_cap_strengthen,
        wf_cap_ignore_map).
  intros Q E F Z S P T WfEnv WfS PsubQ.
  assert (wf_cap E P) as WfP...
  assert (wf_cap E Q) as WfQ...
  assert (wf_cap E P) as WfP'...
  assert (wf_cap E Q) as WfQ'...
  inversion WfP'; inversion WfQ'; inversion WfS;
  unfold subst_cc; subst; simpl...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    eapply sub_cap_reflexivity...
  * inversion PsubQ...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    + eapply sub_cap_universal...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A0)...
      destruct (H4 a)...
      destruct H3...
      destruct H3...
      destruct (H a)...
      destruct H1...
      destruct H1...
    + eapply sub_cap_reflexivity...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    + eapply sub_cap_bound...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H4...
      destruct H4...
      destruct (H a)...
      destruct H1...
      destruct H1...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H4...
      destruct H4...
      destruct (H2 a)...
      destruct H1...
      destruct H1...
      intros y yIn...
      destruct yIn...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
      eapply sub_transitivity_cap with (Q := cset_set A {}N)...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct (H a)...
      destruct H1...
      destruct H1...
      eapply sub_transitivity_cap with (Q := cset_set A0 {}N)...
      rewrite_env (empty ++ map (subst_cb Z (cset_set A0 {}N)) F ++ E).
      eapply sub_cap_weakening...
      eapply sub_cap_bound...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA0...
      destruct (H2 a)...
      destruct H1...
      destruct H1...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
      intros x xInA0...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
    + eapply sub_cap_reflexivity...
Qed.

Lemma sub_cap_through_subst_cc_covariant : forall Q E F Z S P T,
  wf_env (F ++ Z ~ bind_sub_cap T ++ E) ->
  wf_cap (F ++ Z ~ bind_sub_cap T ++ E) S ->
  sub_cap E P Q ->
  sub_cap (map (subst_cb Z Q) F ++ E) (subst_cc Z P S) (subst_cc Z Q S).
Proof with
      repeat (simpl_env;
      try repeat rewrite <- AtomSetFacts.mem_iff in *; 
      try repeat rewrite <- AtomSetFacts.not_mem_iff in *; 
      try repeat rewrite AtomSetFacts.union_iff in *; 

      try repeat rewrite <- union_empty_nats in *;
      try rewrite AtomSetEqual; try rewrite NatSetEqual;
      try AtomSetDecide.fsetdec; try fnsetdec;
      eauto 4 using 
        wf_typ_subst_cbc,
        wf_env_subst_cbc,
        wf_env_subst_tb,
        wf_typ_weaken_head,
        sub_cap_reflexivity,
        wf_cap_strengthen,
        wf_cap_ignore_map).
  intros Q E F Z S P T WfEnv WfS PsubQ.
  assert (wf_cap E P) as WfP...
  assert (wf_cap E Q) as WfQ...
  assert (wf_cap E P) as WfP'...
  assert (wf_cap E Q) as WfQ'...
  inversion WfP'; inversion WfQ'; inversion WfS;
  unfold subst_cc; subst; simpl...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    eapply sub_cap_reflexivity...
  * inversion PsubQ...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    + eapply sub_cap_universal...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A0)...
      destruct (H4 a)...
      destruct H3...
      destruct H3...
      destruct (H a)...
      destruct H1...
      destruct H1...
    + eapply sub_cap_reflexivity...
  * destruct (AtomSetImpl.mem Z _) eqn:ZinA...
    + eapply sub_cap_bound...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H4...
      destruct H4...
      destruct (H a)...
      destruct H1...
      destruct H1...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H4...
      destruct H4...
      destruct (H2 a)...
      destruct H1...
      destruct H1...
      intros y yIn...
      destruct yIn...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
      eapply sub_transitivity_cap with (Q := cset_set A {}N)...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct (H a)...
      destruct H1...
      destruct H1...
      eapply sub_transitivity_cap with (Q := cset_set A0 {}N)...
      rewrite_env (empty ++ map (subst_cb Z (cset_set A0 {}N)) F ++ E).
      eapply sub_cap_weakening...
      eapply sub_cap_bound...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA0...
      destruct (H2 a)...
      destruct H1...
      destruct H1...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
      intros x xInA0...
      eapply sub_cap_in...
      eapply wf_cap_ignore_map...
      econstructor... intros a aInA...
      destruct aInA...
      assert (a <> Z)...
      assert (a `in` A1)...
      destruct (H5 a)...
      destruct H6...
      destruct H6...
      destruct (H2 a)...
      destruct H3...
      destruct H3...
    + eapply sub_cap_reflexivity...
Qed.

Lemma typing_through_subst_ee : forall U C E F x T e u,
  value u ->
  typing (F ++ x ~ bind_typ (pair U C) ++ E) e T ->
  typing E u (pair U C) ->
  typing (map (subst_cb x C) F ++ E) (subst_ee x C u e) (subst_ct x C T).
(* begin show *)

(** We provide detailed comments for the following proof, mainly to
    point out several useful tactics and proof techniques.

    Starting a proof with "Proof with <some tactic>" allows us to
    specify a default tactic that should be used to solve goals.  To
    invoke this default tactic at the end of a proof step, we signal
    the end of the step with three periods instead of a single one,
    e.g., "apply typing_weakening...". *)

Proof with simpl_env;
           eauto using wf_env_subst_tb,
           wf_cap_from_wf_typ,
           sub_typ_through_subst_se,
           wf_typ_from_binds_typ,
           typing_weakening;
           try discriminate.

  (** The proof proceeds by induction on the given typing derivation
      for e.  We use the [remember] tactic, along with [generalize
      dependent], to ensure that the goal is properly strengthened
      before we use induction. *)

  intros U C E F x T e u Val TypT TypU.
  assert (typing (F ++ x ~ bind_typ (pair U C) ++ E) e T) as TypE...
  remember (F ++ x ~ bind_typ (pair U C) ++ E) as E'.
  generalize dependent F.
  induction TypT; intros F EQ; subst; simpl subst_ee...

  (** The [typing_var] case involves a case analysis on whether the
      variable is the same as the one being substituted for. *)

  Case "typing_var".
    destruct (x0 == x); try subst x0.

    (** In the case where [x0=x], we first observe that hypothesis
        [H0] implies that [T=U], since [x] can only be bound once in
        the environment.  The conclusion then follows from hypothesis
        [TypU] and weakening.  We can use the [analyze_binds_uniq]
        tactic, described in the MetatheoryEnv library, with [H0] to
        obtain the fact that [T=U]. *)

    SCase "x0 = x".
      analyze_binds_uniq H0.
        injection BindsTacVal; intros; subst.


        (** In order to apply [typing_weakening], we need to rewrite
            the environment so that it has the right shape.  (We could
            also prove a corollary of typing_weakening.)  The
            [rewrite_env] tactic, described in the Environment
            library, is one way to perform this rewriting. *)
        assert (x `notin` fv_cs U) as FrX.
          eapply (notin_fv_wf_shp) with (E := E)...
        simpl subst_ct...
        rewrite <- subst_cs_fresh...
        rewrite evaluate_subst_cc...
        rewrite_env (empty ++ (map (subst_cb x C) F ++ E)).
        apply typing_weakening...

    (** In the case where [x0<>x], the result follows by an exhaustive
        case analysis on exactly where [x0] is bound in the
        environment.  We perform this case analysis by using the
        [analyze_binds] tactic, described in the MetatheoryEnv
        library. *)

    SCase "x0 <> x".
      analyze_binds H0; simpl subst_ct...
      erewrite <- subst_cc_fresh with (T := cset_fvar x0)...
      eapply typing_var with (C := (subst_cc x C C0))...
      replace (bind_typ (pair (subst_cs x C S) (subst_cc x C C0))) with 
        (subst_cb x C (bind_typ (pair S C0)))...
      erewrite <- subst_cc_fresh with (T := cset_fvar x0)...
      erewrite <- subst_cs_fresh... eapply notin_fv_wf_shp with (E := E)...
      eapply fresh_mid_tail...
  (** Informally, the [typing_abs] case is a straightforward
      application of the induction hypothesis, which is called [H0]
      here. *)

  Case "typing_abs".

    (** We use the "pick fresh and apply" tactic to apply the rule
        [typing_abs] without having to calculate the appropriate
        finite set of atoms. *)
    unfold subst_ct; fold subst_ct.
    (** TODO : lemma / substitution commutes with fv_exp_for_cap *)
    eenough 
      (typing _ _
        (pair (shp_arrow (subst_ct x C V) (subst_ct x C T1))
        (cset_set (fv_exp_for_cap (subst_ee x C u e1)) {}N))) as GoodTyp.
      eapply typing_sub. eapply GoodTyp. econstructor...
      unshelve epose proof (capture_prediction _ _ _ _ _ TypU)
        as CapU...
      rewrite fv_exp_for_cap_through_subst_ee at 1.
      eapply sub_cap_through_subst_ct_covariant...
      (** need to do a subcapturing judgment. 
        Note that x is not in u, so the only thing that can happen is that
        1. fv_exp_for_cap e1 is bound in [F, x, E].
        2. x `notin` u, so fv_exp_for_cap e1[x->C,u] is a strict subset of
            [fv_exp_for_cap e1][x -> C]
      *)
      eapply sub_shp_reflexivity...
    pick fresh y and apply typing_abs.

    (** We cannot apply [H0] directly here.  The first problem is that
        the induction hypothesis has [(subst_ee open_ee)], whereas in
        the goal we have [(open_ee subst_ee)].  The lemma
        [subst_ee_open_ee_var] lets us swap the order of these two
        operations. *)
    rewrite subst_ct_open_ct_var...
    (** argh F *)
    erewrite subst_cc_fresh with (U := C) (T := cset_fvar y) at 1...
    rewrite subst_ee_open_ee_var...

    (** The second problem is how the concatenations are associated in
        the environments.  In the goal, we currently have

<<       (y ~ bind_typ V ++ F ++ E),
>>
        where concatenation associates to the right.  In order to
        apply the induction hypothesis, we need

<<        ((y ~ bind_typ V ++ F) ++ E).
>>
        We can use the [rewrite_env] tactic to perform this rewriting,
        or we can rewrite directly with an appropriate lemma from the
        MetatheoryEnv library. *)

    rewrite_env ((map (subst_cb x C) (y ~ bind_typ V ++ F)) ++ E).

    (** Now we can apply the induction hypothesis. *)

    apply H0...
  (** The remaining cases in this proof are straightforward, given
      everything that we have pointed out above. *)
  Case "typing_app".
    unshelve epose proof (IHTypT1 _ _)...
    rewrite subst_ct_open_ct...
    eapply typing_app...
    simpl in H...
  Case "typing_sabs".
    simpl...
    eenough 
      (typing _ _
        (pair (shp_sall (subst_cs x C V) (subst_ct x C T1))
        (cset_set (fv_exp_for_cap (subst_ee x C u e1)) {}N))) as GoodTyp.
      eapply typing_sub. eapply GoodTyp. econstructor...
      (** need to do a subcapturing judgment. 
        Note that x is not in u, so the only thing that can happen is that
        1. fv_exp_for_cap e1 is bound in [F, x, E].
        2. x `notin` u, so fv_exp_for_cap e1[x->C,u] is a strict subset of
            [fv_exp_for_cap e1][x -> C]
      *)
      unshelve epose proof (capture_prediction _ _ _ _ _ TypU) as CapU...
      rewrite fv_exp_for_cap_through_subst_ee at 1.

      eapply sub_cap_through_subst_ct_covariant...
      eapply sub_shp_reflexivity...
    
    pick fresh Y and apply typing_sabs.
    rewrite subst_ee_open_se_var...
    replace (open_st (subst_ct x C T1) Y)
      with (open_st (subst_ct x C T1) (subst_cs x C Y))...
    rewrite <- subst_ct_open_st.
    rewrite_env ((map (subst_cb x C) (Y ~ bind_sub_shp V ++ F)) ++ E).
    apply H0...
  Case "typing_sapp".
    unshelve epose proof (IHTypT _ _)...
    rewrite subst_ct_open_st...
    eapply typing_sapp...
    simpl in H0...
    eapply sub_shp_through_subst_se...
    eapply sub_cap_reflexivity...
  (** these two admits are like the case for abs/app.  Also see 
      typing_through_subst_ce*)
  Case "typing_cabs".
    (** We use the "pick fresh and apply" tactic to apply the rule
        [typing_abs] without having to calculate the appropriate
        finite set of atoms. *)
    unfold subst_ct; fold subst_ct.
    (** TODO : lemma / substitution commutes with fv_exp_for_cap *)
    eenough 
      (typing _ _
        (pair (shp_call (subst_cc x C V) (subst_ct x C T1))
        (cset_set (fv_exp_for_cap (subst_ee x C u e1)) {}N))) as GoodTyp.
      eapply typing_sub. eapply GoodTyp. econstructor...
      unshelve epose proof (capture_prediction _ _ _ _ _ TypU)
        as CapU...
      rewrite fv_exp_for_cap_through_subst_ee at 1.
      eapply sub_cap_through_subst_ct_covariant...
      (** need to do a subcapturing judgment. 
        Note that x is not in u, so the only thing that can happen is that
        1. fv_exp_for_cap e1 is bound in [F, x, E].
        2. x `notin` u, so fv_exp_for_cap e1[x->C,u] is a strict subset of
            [fv_exp_for_cap e1][x -> C]
      *)
      eapply sub_shp_reflexivity...
    pick fresh y and apply typing_cabs.

    (** We cannot apply [H0] directly here.  The first problem is that
        the induction hypothesis has [(subst_ee open_ee)], whereas in
        the goal we have [(open_ee subst_ee)].  The lemma
        [subst_ee_open_ee_var] lets us swap the order of these two
        operations. *)
    rewrite subst_ct_open_ct_var...
    (** argh F *)
    
    rewrite subst_ee_open_ce_var...

    (** The second problem is how the concatenations are associated in
        the environments.  In the goal, we currently have

<<       (y ~ bind_typ V ++ F ++ E),
>>
        where concatenation associates to the right.  In order to
        apply the induction hypothesis, we need

<<        ((y ~ bind_typ V ++ F) ++ E).
>>
        We can use the [rewrite_env] tactic to perform this rewriting,
        or we can rewrite directly with an appropriate lemma from the
        MetatheoryEnv library. *)

    rewrite_env ((map (subst_cb x C) (y ~ bind_sub_cap V ++ F)) ++ E).

    (** Now we can apply the induction hypothesis. *)

    apply H0...
  Case "typing_capp".
    unshelve epose proof (IHTypT _ _)...
    rewrite subst_ct_open_ct...
    eapply typing_capp...
    simpl in H0...
    eapply sub_cap_through_subst_ce...
    eapply sub_cap_reflexivity...
  Case "typing_sub".
    eapply typing_sub...
    eapply sub_typ_through_subst_se...
    eapply sub_cap_reflexivity...
Qed.
(* end show *)


(************************************************************************ *)
(** ** Type substitution preserves typing (11) *)

Lemma subst_se_through_fv_exp_for_cap : forall Z P e,
  (fv_exp_for_cap e) = (fv_exp_for_cap (subst_se Z P e)).
Proof with eauto.
  intros.
  induction e; simpl...
  rewrite IHe1.
  rewrite IHe2...
Qed.

Lemma typing_through_subst_se : forall Q E F Z e T P,
  typing (F ++ Z ~ bind_sub_shp Q ++ E) e T ->
  sub_shp E P Q ->
  typing (map (subst_sb Z P) F ++ E) (subst_se Z P e) (subst_st Z P T).
Proof with simpl_env;
           eauto 6 using wf_env_subst_sbs,
                         wf_typ_subst_sbs,
                         sub_shp_through_subst_ss,
                         sub_typ_through_subst_ss.
  intros Q E F Z e T P Typ PsubQ.
  remember (F ++ Z ~ bind_sub_shp Q ++ E) as G.
  generalize dependent F.
  induction Typ; intros F EQ; subst;
    simpl subst_se in *; simpl subst_st in *; simpl subst_ss in *...
  Case "typing_var".
    eapply typing_var with (C := C)...
      rewrite (map_subst_sb_id E Z P);
        [ | auto | eapply fresh_mid_tail; eauto ].
      replace (bind_typ (pair (subst_ss Z P S) C))
        with (subst_sb Z P (bind_typ (pair S C)))...
      analyze_binds H0...
  Case "typing_abs".
    (** Substituting a _type_ variable does not change capture
        fv_exp_for_cap. *)
    erewrite subst_se_through_fv_exp_for_cap.
    pick fresh y and apply typing_abs.
    
    rewrite subst_se_open_ee_var...
    rewrite <- subst_st_open_ct...
    rewrite_env (map (subst_sb Z P) (y ~ bind_typ V ++ F) ++ E).
    apply H0...
  Case "typing_app".
    unshelve epose proof (IHTyp1 _ _)...
    rewrite subst_st_open_ct...
  Case "typing_sabs".
    (** Substituting a _type_ variable does not change capture
        fv_exp_for_cap. *)
    erewrite subst_se_through_fv_exp_for_cap.

    pick fresh Y and apply typing_sabs.
    rewrite subst_se_open_se_var...
    rewrite subst_st_open_st_var...
    rewrite_env (map (subst_sb Z P) (Y ~ bind_sub_shp V ++ F) ++ E).
    apply H0...
  Case "typing_tapp".
    rewrite subst_st_open_st...
  Case "typing_cabs".
    erewrite subst_se_through_fv_exp_for_cap.

    pick fresh Y and apply typing_cabs.
    rewrite <- subst_se_open_ce...
    rewrite <- subst_st_open_ct...
    rewrite_env (map (subst_sb Z P) (Y ~ bind_sub_cap V ++ F) ++ E).
    apply H0...
  Case "typing_capp".
    rewrite subst_st_open_ct...
    eapply typing_capp...
    eapply sub_cap_strengthening_shp...
    eapply sub_cap_narrowing_shp...
Qed.

Lemma fv_exp_for_cap_through_subst_cc : forall X C e,
  X `notin` fv_exp_for_cap e ->
  (cset_set (fv_exp_for_cap (subst_ce X C e)) {}N) = 
    (subst_cc X C (cset_set (fv_exp_for_cap e) {}N)).
Proof with eauto; 
  try repeat rewrite <- AtomSetFacts.mem_iff in *; 
  try repeat rewrite <- AtomSetFacts.not_mem_iff in *; 
  try rewrite AtomSetEqual; try rewrite NatSetEqual;
  try AtomSetDecide.fsetdec; try fnsetdec.
  intros.
  (*** this proof is cursed ****)
  induction e; simpl; unfold subst_cc in *; simpl in *...
  * destruct (AtomSetImpl.mem X _) eqn:XinE...
  * destruct (a == X); subst...
    + destruct (AtomSetImpl.mem X _) eqn:XinX; f_equal...
  * destruct (AtomSetImpl.mem X (fv_exp_for_cap e1)) eqn:XinE1;
    destruct (AtomSetImpl.mem X (fv_exp_for_cap e2)) eqn:XinE2;
    destruct (AtomSetImpl.mem X (union (fv_exp_for_cap e1) (fv_exp_for_cap e2)))
      eqn:XinE1E2;
      repeat(
      try specialize (IHe1 XinE1);
      try specialize (IHe2 XinE2);
      try rewrite IHe1; 
      try rewrite IHe2; 
      subst)...
  try specialize (IHe1 XinE1);
  try specialize (IHe2 XinE2);
  f_equal...
  inversion IHe1...
  inversion IHe2...
Qed.

Lemma notin_fv_exp_cap_open_ee : forall Z e k x,
  Z <> x ->
  Z `notin` fv_exp_for_cap (open_ee_rec k x (cset_fvar x) e) ->
  Z `notin` fv_exp_for_cap e.
Proof with eauto.
  intros. generalize dependent k.
  induction e; simpl...
Qed.

Lemma notin_fv_exp_cap_open_se : forall Z e k X,
  Z `notin` fv_exp_for_cap (open_se_rec k X e) ->
  Z `notin` fv_exp_for_cap e.
Proof with eauto.
  intros. generalize dependent k.
  induction e; simpl...
Qed.


Lemma notin_fv_exp_cap_open_ce : forall Z e k X,
  Z <> X ->
  Z `notin` fv_exp_for_cap (open_ce_rec k (cset_fvar X) e) ->
  Z `notin` fv_exp_for_cap e.
Proof with eauto.
  intros. generalize dependent k.
  induction e; simpl...
Qed.


Lemma capture_variables_are_not_term_variables : forall Z Q E e T,
  typing E e T ->
  binds Z (bind_sub_cap Q) E ->
  Z `notin` fv_exp_for_cap e.
Proof with eauto.
  intros * Typ Binds.
  induction Typ; simpl...
  * destruct (x == Z); subst...
    exfalso. eapply binds_unique in H0...
    inversion H0...
  * (* Z `notin` fv_cap e1[0 -> x] --> Z `notin` fv_cap e1 -- needs lemma *)
    pick fresh x.
    eapply notin_fv_exp_cap_open_ee with (x := x)...
  * (* same as above *)
    pick fresh X.
    eapply notin_fv_exp_cap_open_se with (X := X)...
  * (* same as above *)
    pick fresh X.
    eapply notin_fv_exp_cap_open_ce with (X := X)...
Qed.

Lemma typing_through_subst_ce : forall Q E F Z e T P,
  typing (F ++ Z ~ bind_sub_cap Q ++ E) e T ->
  sub_cap E P Q ->
  typing (map (subst_cb Z P) F ++ E) (subst_ce Z P e) (subst_ct Z P T).
Proof with simpl_env;
           eauto 6 using wf_env_subst_sbs,
                         wf_env_subst_cbc,
                         wf_typ_subst_sbs,
                         wf_cap_subst_cbc,
                         sub_shp_through_subst_ss,
                         sub_shp_through_subst_sc,
                         sub_cap_through_subst_cc,
                         sub_typ_through_subst_sc,
                         sub_shp_reflexivity.
  intros Q E F Z e T P Typ PsubQ.
  assert (typing (F ++ Z ~ bind_sub_cap Q ++ E) e T) as TypE...
  remember (F ++ Z ~ bind_sub_cap Q ++ E) as G.
  generalize dependent F.
  induction Typ; intros F EQ; subst;
    simpl subst_ce in *; simpl subst_ct in *; simpl subst_cs in *...
  Case "typing_var".
    analyze_binds H0...
      erewrite <- subst_cc_fresh with (T := cset_fvar x)...
      eapply typing_var with (C := (subst_cc Z P C))...
      replace (bind_typ (pair (subst_cs Z P S) (subst_cc Z P C)))
        with (subst_cb Z P (bind_typ (pair S C)))...
      eapply notin_fv_wf_cap. eapply wf_cap_binds_typ...
      eapply fresh_mid_head...
      erewrite <- subst_cc_fresh with (T := cset_fvar x)...
      erewrite <- subst_cs_fresh with (T := S)...
      eapply notin_fv_wf_shp. 
      eapply wf_shp_from_wf_typ. 
      eapply wf_typ_from_binds_typ with (E := E)...
      eapply fresh_mid_tail...
      eapply notin_fv_wf_cap. eapply wf_cap_binds_typ...
      eapply fresh_mid_tail...
  Case "typing_abs".
    (** TODO : lemma / substitution commutes with fv_exp_for_cap *)
    eenough 
      (typing _ _
        (pair (shp_arrow (subst_ct Z P V) (subst_ct Z P T1))
        (cset_set (fv_exp_for_cap (subst_ce Z P e1)) {}N))) as GoodTyp.
      eapply typing_sub. eapply GoodTyp. econstructor...
      (** need to do a subcapturing judgment. 
        Note that x is not in u, so the only thing that can happen is that
        1. fv_exp_for_cap e1 is bound in [F, Z, E].
        2. Z `notin` u, so fv_exp_for_cap e1[Z->P,u] is a strict subset of
            [fv_exp_for_cap e1][Z->P]
      *)   

      rewrite fv_exp_for_cap_through_subst_cc at 1.
      eapply sub_cap_reflexivity...
      eapply wf_cap_subst_cbc with (Q := Q)...
      replace (fv_exp_for_cap e1) with (fv_exp_for_cap (exp_abs V e1))...
      eapply capture_variables_are_not_term_variables...
    pick fresh y and apply typing_abs.
    erewrite (subst_cc_fresh) with (T := cset_fvar y)...
    erewrite (subst_ce_fresh) with (e := y)...
    rewrite <- subst_ce_open_ee...
    rewrite <- subst_ct_open_ct...
    rewrite_env (map (subst_cb Z P) (y ~ bind_typ V ++ F) ++ E).
    apply H0...
  Case "typing_app".
    unshelve epose proof (IHTyp1 _ _)...
    rewrite subst_ct_open_ct...
  Case "typing_sabs".
    eenough 
      (typing _ _
        (pair (shp_sall (subst_cs Z P V) (subst_ct Z P T1))
        (cset_set (fv_exp_for_cap (subst_ce Z P e1)) {}N))) as GoodTyp.
      eapply typing_sub. eapply GoodTyp. econstructor...
      (** need to do a subcapturing judgment. 
        Note that x is not in u, so the only thing that can happen is that
        1. fv_exp_for_cap e1 is bound in [F, x, E].
        2. x `notin` u, so fv_exp_for_cap e1[x->C,u] is a strict subset of
            [fv_exp_for_cap e1][x -> C]
      *)
      rewrite fv_exp_for_cap_through_subst_cc at 1.
      eapply sub_cap_reflexivity...
      eapply wf_cap_subst_cbc with (Q := Q)...
      replace (fv_exp_for_cap e1) with (fv_exp_for_cap (exp_sabs V e1))...
      eapply capture_variables_are_not_term_variables...

    pick fresh Y and apply typing_sabs.
    erewrite (subst_cs_fresh) with (T := Y)...
    rewrite <- subst_ce_open_se...
    rewrite <- subst_ct_open_st...
    rewrite_env (map (subst_cb Z P) (Y ~ bind_sub_shp V ++ F) ++ E).
    apply H0...
  Case "typing_sapp".
    rewrite subst_ct_open_st...
  Case "typing_cabs".
    eenough 
    (typing _ _
      (pair (shp_call (subst_cc Z P V) (subst_ct Z P T1))
      (cset_set (fv_exp_for_cap (subst_ce Z P e1)) {}N))) as GoodTyp.
        eapply typing_sub. eapply GoodTyp. econstructor...
        (** need to do a subcapturing judgment. 
          Note that x is not in u, so the only thing that can happen is that
          1. fv_exp_for_cap e1 is bound in [F, x, E].
          2. x `notin` u, so fv_exp_for_cap e1[x->C,u] is a strict subset of
              [fv_exp_for_cap e1][x -> C]
        *)
        rewrite fv_exp_for_cap_through_subst_cc at 1.
        eapply sub_cap_reflexivity...
        eapply wf_cap_subst_cbc with (Q := Q)...
        replace (fv_exp_for_cap e1) with (fv_exp_for_cap (exp_cabs V e1))...
        eapply capture_variables_are_not_term_variables...

    pick fresh Y and apply typing_cabs.
    (** has to be a better way to do this: Z <> Y *)
    erewrite (subst_cc_fresh) with (T := cset_fvar Y)...
    rewrite <- subst_ce_open_ce...
    rewrite <- subst_ct_open_ct...
    rewrite_env (map (subst_cb Z P) (Y ~ bind_sub_cap V ++ F) ++ E).
    apply H0...
  Case "typing_capp".
    rewrite subst_ct_open_ct...
Qed.


(* ********************************************************************** *)
(** * #<a name="preservation"></a># Preservation *)


(* ********************************************************************** *)
(** ** Inversion of typing (13) *)

Lemma typing_inv_abs : forall E S1 e1 T,
  typing E (exp_abs S1 e1) T ->
  forall C U1 U2, sub_typ E T (pair (shp_arrow U1 U2) C) ->
     sub_typ E U1 S1
  /\ exists D, exists S2, exists L, forall x, x `notin` L ->
     typing (x ~ bind_typ S1 ++ E) 
      (open_ee e1 x (cset_fvar x))
      (open_ct S2 (cset_fvar x)) 
      /\ sub_typ (x ~ bind_typ U1 ++ E) (open_ct S2 (cset_fvar x)) 
                  (open_ct U2 (cset_fvar x))
      /\ sub_cap E D C.
Proof with auto.
  intros E S1 e1 T Typ.
  remember (exp_abs S1 e1) as e.
  generalize dependent e1.
  generalize dependent S1.
  induction Typ; intros S1 b1 EQ C' U1 U2 Sub; inversion EQ; subst.
  Case "typing_abs".
    inversion Sub; subst.
    inversion H7; subst...
    split...
    exists  (cset_set (fv_exp_for_cap b1) {}N). exists T1. exists (L `union` L0)...
  Case "typing_sub".
    auto using (sub_transitivity_typ T).
Qed.

Lemma typing_inv_sabs : forall E S1 e1 T,
  typing E (exp_sabs S1 e1) T ->
  forall C U1 U2, sub_typ E T (pair (shp_sall U1 U2) C) ->
     sub_shp E U1 S1
  /\ exists D, exists S2, exists L, forall X, X `notin` L ->
     typing (X ~ bind_sub_shp U1 ++ E) (open_se e1 X) (open_st S2 X)
     /\ sub_typ (X ~ bind_sub_shp U1 ++ E) (open_st S2 X) (open_st U2 X)
     /\ sub_cap (X ~ bind_sub_shp U1 ++ E) D C.
Proof with simpl_env; auto.
  intros E S1 e1 T Typ.
  remember (exp_sabs S1 e1) as e.
  generalize dependent e1.
  generalize dependent S1.
  induction Typ; intros S1 e0 EQ C' U1 U2 Sub; inversion EQ; subst.
  Case "typing_tabs".
    inversion Sub; subst.
    inversion H7; subst...
    split...
    exists (cset_set (fv_exp_for_cap e0) {}N).
    exists T1.
    exists (L0 `union` L `union` dom E).
    intros Y Fr.
    rewrite_env (empty ++ Y ~ bind_sub_shp U1 ++ E).
    split.
    apply (typing_narrowing_shp S1)...
    split.
    eauto.
    eapply (sub_cap_weakening)...
  Case "typing_sub".
    auto using (sub_transitivity_typ T).
Qed.


Lemma typing_inv_cabs : forall E S1 e1 T,
  typing E (exp_cabs S1 e1) T ->
  forall C U1 U2, sub_typ E T (pair (shp_call U1 U2) C) ->
     sub_cap E U1 S1
  /\ exists D, exists S2, exists L, forall X, X `notin` L ->
     typing (X ~ bind_sub_cap U1 ++ E) (open_ce e1 (cset_fvar X)) (open_ct S2 (cset_fvar X))
     /\ sub_typ (X ~ bind_sub_cap U1 ++ E) (open_ct S2 (cset_fvar X)) (open_ct U2 (cset_fvar X))
     /\ sub_cap (X ~ bind_sub_cap U1 ++ E) D C.
Proof with simpl_env; auto.
  intros E S1 e1 T Typ.
  remember (exp_cabs S1 e1) as e.
  generalize dependent e1.
  generalize dependent S1.
  induction Typ; intros S1 e0 EQ C' U1 U2 Sub; inversion EQ; subst.
  Case "typing_tabs".
    inversion Sub; subst.
    inversion H7; subst...
    split...
    exists (cset_set (fv_exp_for_cap e0) {}N).
    exists T1.
    exists (L0 `union` L `union` dom E).
    intros Y Fr.
    rewrite_env (empty ++ Y ~ bind_sub_cap U1 ++ E).
    split.
    apply (typing_narrowing_cap S1)...
    split.
    eauto.
    eapply (sub_cap_weakening)...
  Case "typing_sub".
    auto using (sub_transitivity_typ T).
Qed.

(* ********************************************************************** *)
(** ** Preservation (20) *)

Lemma preservation : forall E e e' T,
  typing E e T ->
  red e e' ->
  typing E e' T.
Proof with simpl_env; eauto using sub_typ_reflexivity, sub_shp_reflexivity.
  intros E e e' T Typ. generalize dependent e'.
  induction Typ; intros e' Red; try solve [ inversion Red; subst; eauto ].
  Case "typing_app".
    inversion Red; subst...
    SCase "red_abs".
      destruct (typing_inv_abs _ _ _ _ Typ1 D (pair T1 C) T2) as [P1 [D' [S2 [L P2]]]].
        apply sub_typ_reflexivity...
      pick fresh x.
      destruct (P2 x) as [? [? ?]]...
      rewrite (subst_ee_intro x)...
      rewrite (subst_ct_intro x)...
      rewrite_env ((map (subst_cb x C)) empty ++ E).
      destruct T as [Ts Tc].
      eapply (typing_through_subst_ee) with (U := T1)...
      apply (typing_sub (open_ct S2 (cset_fvar x)))...
        rewrite_env (empty ++ x ~ bind_typ (pair T1 C) ++ E).
        eapply typing_narrowing_typ...
  Case "typing_sapp".
    inversion Red; subst...
    SCase "red_sabs".
      destruct (typing_inv_sabs _ _ _ _ Typ C Sh1 T2) as [P1 [D [S2 [L P2]]]].
        apply sub_typ_reflexivity...
      pick fresh X.
      destruct (P2 X) as [? [? ?]]...
      rewrite (subst_se_intro X)...
      rewrite (subst_st_intro X)...
      rewrite_env (map (subst_sb X Sh) empty ++ E).
      apply (typing_through_subst_se Sh1)...
  Case "typing_capp".
    inversion Red; subst...
    SCase "red_cabs".
      destruct (typing_inv_cabs _ _ _ _ Typ D C1 T2) as [P1 [D' [S2 [L P2]]]].
        apply sub_typ_reflexivity...
      pick fresh X.
      destruct (P2 X) as [? [? ?]]...
      rewrite (subst_ce_intro X)...
      rewrite (subst_ct_intro X)...
      rewrite_env (map (subst_cb X C) empty ++ E).
      apply (typing_through_subst_ce C1)...
Qed.


(* ********************************************************************** *)
(** * #<a name="progress"></a># Progress *)


(* ********************************************************************** *)
(** ** Canonical forms (14) *)

Lemma canonical_form_abs : forall e U1 U2 C,
  value e ->
  typing empty e (pair (shp_arrow U1 U2) C) ->
  exists V, exists e1, e = exp_abs V e1.
Proof with eauto.
  intros e U1 U2 C Val Typ.
  remember empty as E.
  remember (pair (shp_arrow U1 U2) C) as T.
  revert U1 U2 C HeqT HeqE.
  induction Typ; intros U1 U2 C' EQT EQE; subst;
    try solve [ inversion Val | inversion EQT | eauto ].
  Case "typing_sub".
    inversion H; subst; eauto.
    inversion H5; subst... 
    analyze_binds H0.
Qed.

Lemma canonical_form_sabs : forall e U1 U2 C,
  value e ->
  typing empty e (pair (shp_sall U1 U2) C) ->
  exists V, exists e1, e = exp_sabs V e1.
Proof.
  intros e U1 U2 C Val Typ.
  remember empty as E.
  remember (pair (shp_sall U1 U2) C) as T.
  revert U1 U2 C HeqT HeqT.
  induction Typ; intros U1 U2 C' EQT EQE; subst;
    try solve [ inversion Val | inversion EQT | eauto ].
  Case "typing_sub".
    inversion H; subst; eauto.
    inversion H5; subst; eauto.
    analyze_binds H0.
Qed.

Lemma canonical_form_cabs : forall e U1 U2 C,
  value e ->
  typing empty e (pair (shp_call U1 U2) C) ->
  exists V, exists e1, e = exp_cabs V e1.
Proof.
  intros e U1 U2 C Val Typ.
  remember empty as E.
  remember (pair (shp_call U1 U2) C) as T.
  revert U1 U2 C HeqT HeqT.
  induction Typ; intros U1 U2 C' EQT EQE; subst;
    try solve [ inversion Val | inversion EQT | eauto ].
  Case "typing_sub".
    inversion H; subst; eauto.
    inversion H5; subst; eauto.
    analyze_binds H0.
Qed.

(* ********************************************************************** *)
(** ** Progress (16) *)

Lemma progress : forall e T,
  typing empty e T ->
  value e \/ exists e', red e e'.
Proof with eauto.
  intros e T Typ.
  remember empty as E. generalize dependent HeqE.
  assert (Typ' : typing E e T)...
  induction Typ; intros EQ; subst...
  Case "typing_var".
    inversion H0.
  Case "typing_app".
    right.
    destruct IHTyp1 as [Val1 | [e1' Rede1']]...
    SCase "Val1".
      destruct IHTyp2 as [Val2 | [e2' Rede2']]...
      SSCase "Val2".
        destruct (canonical_form_abs _ _ _ _ Val1 Typ1) as [S [e3 EQ]].
        subst.
        exists (open_ee e3 e2 C)...
  Case "typing_tapp".
    right.
    destruct IHTyp as [Val1 | [e1' Rede1']]...
    SCase "Val1".
      destruct (canonical_form_sabs _ _ _ _ Val1 Typ) as [S [e3 EQ]].
      subst.
      exists (open_se e3 Sh)...
  Case "typing_cpp".
    right.
    destruct IHTyp as [Val1 | [e1' Rede1']]...
    SCase "Val1".
      destruct (canonical_form_cabs _ _ _ _ Val1 Typ) as [S [e3 EQ]].
      subst.
      exists (open_ce e3 C)...
Qed.
